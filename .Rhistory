trial$base_num=0
trial$base_num[positives]=1
baseline_analysis = Analyse_baseline(trial=trial,
baselineNumerator='base_num',
baselineDenominator='base_denom',
method='aovs',
ci.type=NULL)
ICC = baseline_analysis$estimates$ICC
ICCs = c(ICCs,ICC)
cat("bandwidth: ",bw[iter]*approx_diag,"  ICC=",ICC,"\n")
deviation = ICC - ICC_inp
}
}
}
# use contamination range if this is available
if (!is.null(theta_inp)){
sd = theta_inp/(sqrt(2)*qnorm(0.95))
}
if (is.null(sd)){
print('Error: contamination range or s.d. of spatial kernel must be provided')
trial = NULL
return(trial)
}
initial_guess_bandwidth <- 0.0375/ICC_inp #bandwidth for KDE. The value of 0.0375 is from analysis of
# compute approximate diagonal of clusters
approx_diag = sqrt((max(trial$x)-min(trial$x))^2 + (max(trial$y)-min(trial$y))^2)/sqrt(length(unique(trial$cluster)))
# scale bandwidth by cluster diagonal
scaled_initial_guess = initial_guess_bandwidth/approx_diag
# number of positives required to match the specified prevalence
npositives = round(initialPrevalence*nrow(trial))
euclid <- distance_matrix(trial$x, trial$y)
bw = scaled_initial_guess*c(0.25,0.5,1,2,4)
iter = 0
deviation = 999
ICCs = c()
cat("Estimating the smoothing required to achieve the target ICC","/n")
cat("Estimating the smoothing required to achieve the target ICC","\n")
iter=iter+1
#use a linear model fitted to log(bw) to estimate the required bandwidth
if(iter > 5){
lp = ICCs - ICC_inp
logbw_i = min(2,lm(formula = log(bw) ~ lp)$coefficients[1]) #impose a maximum on bw
bw = c(bw, exp(logbw_i))
}
#assign initial pattern
trial$infectiousness_proxy <- KDESmoother(trial$x,trial$y,kernnumber=200,bandwidth=bw[iter],low=0.0,high=1.0)
# Smooth the exposure proxy to allow for mosquito movement
# Note that the s.d. in each dimension of the 2 d gaussian is sd/sqrt(2)
# smoothedBaseline is the amount received by the each cluster from the contributions (infectiousness_proxy) of each source
smoothedBaseline <-  gauss(sd, euclid) %*% trial$infectiousness_proxy
# scale to input value of initial prevalence by assigning required number of infections with probabilities proportionate
# to infectiousness_proxy
positives = sample(x=nrow(trial),size=npositives,replace=FALSE,prob=smoothedBaseline)
trial$base_denom=1
trial$base_num=0
trial$base_num[positives]=1
baseline_analysis = Analyse_baseline(trial=trial,
baselineNumerator='base_num',
baselineDenominator='base_denom',
method='aovs',
ci.type=NULL)
ICC = baseline_analysis$estimates$ICC
ICCs = c(ICCs,ICC)
cat("bandwidth: ",bw[iter]*approx_diag,"  ICC=",ICC,"\n")
deviation = ICC - ICC_inp
# scale to input value of initial prevalence by assigning required number of infections with probabilities proportionate
# to infectiousness_proxy
positives = sample(x=nrow(trial),size=npositives,replace=FALSE,prob=smoothedBaseline)
npositives
trial$npositives
# number of positives required to match the specified prevalence
npositives = round(initialPrevalence*nrow(trial))
library(CRTspillover)
remove(test_Simulate_CRT)
library(CRTspillover)
test_Simulate_CRT=Simulate_CRT(theta_inp=1.2,initialPrevalence=0.4)
# use contamination range if this is available
if (!is.null(theta_inp)){
sd = theta_inp/(sqrt(2)*qnorm(0.95))
}
if (is.null(sd)){
print('Error: contamination range or s.d. of spatial kernel must be provided')
trial = NULL
return(trial)
}
# generate baseline data if required and exposure proxy if this is not provided
if(!"infectiousness_proxy" %in% colnames(trial) &
baselineNumerator %in% colnames(trial) &
baselineDenominator %in% colnames(trial)) {
trial$infectiousness_proxy = trial[[baselineNumerator]]/trial[[baselineDenominator]]
} else {
if(generateBaseline) {
##############################################################################
# simulate baseline data with a specified ICC
# parameters of the spatial pattern of prevalence
initial_guess_bandwidth <- 0.0375/ICC_inp #bandwidth for KDE. The value of 0.0375 is from analysis of
# a sample of simulations based on Rusinga geography
# compute approximate diagonal of clusters
approx_diag = sqrt((max(trial$x)-min(trial$x))^2 + (max(trial$y)-min(trial$y))^2)/sqrt(length(unique(trial$cluster)))
# scale bandwidth by cluster diagonal
scaled_initial_guess = initial_guess_bandwidth/approx_diag
# number of positives required to match the specified prevalence
npositives = round(initialPrevalence*nrow(trial))
# For the smoothing step compute contributions to the relative effect size
# from other households as a function of distance to the other households
euclid <- distance_matrix(trial$x, trial$y)
bw = scaled_initial_guess*c(0.25,0.5,1,2,4)
iter = 0
deviation = 999
ICCs = c()
cat("Estimating the smoothing required to achieve the target ICC","\n")
while(abs(deviation) > tol){
iter=iter+1
#use a linear model fitted to log(bw) to estimate the required bandwidth
if(iter > 5){
lp = ICCs - ICC_inp
logbw_i = min(2,lm(formula = log(bw) ~ lp)$coefficients[1]) #impose a maximum on bw
bw = c(bw, exp(logbw_i))
}
#assign initial pattern
trial$infectiousness_proxy <- KDESmoother(trial$x,trial$y,kernnumber=200,bandwidth=bw[iter],low=0.0,high=1.0)
# Smooth the exposure proxy to allow for mosquito movement
# Note that the s.d. in each dimension of the 2 d gaussian is sd/sqrt(2)
# smoothedBaseline is the amount received by the each cluster from the contributions (infectiousness_proxy) of each source
smoothedBaseline <-  gauss(sd, euclid) %*% trial$infectiousness_proxy
# scale to input value of initial prevalence by assigning required number of infections with probabilities proportionate
# to infectiousness_proxy
positives = sample(x=nrow(trial),size=npositives,replace=FALSE,prob=smoothedBaseline)
trial$base_denom=1
trial$base_num=0
trial$base_num[positives]=1
baseline_analysis = Analyse_baseline(trial=trial,
baselineNumerator='base_num',
baselineDenominator='base_denom',
method='aovs',
ci.type=NULL)
ICC = baseline_analysis$estimates$ICC
ICCs = c(ICCs,ICC)
cat("bandwidth: ",bw[iter]*approx_diag,"  ICC=",ICC,"\n")
deviation = ICC - ICC_inp
}
}
}
devtools::load_all()
# use contamination range if this is available
if (!is.null(theta_inp)){
sd = theta_inp/(sqrt(2)*qnorm(0.95))
}
if (is.null(sd)){
print('Error: contamination range or s.d. of spatial kernel must be provided')
trial = NULL
return(trial)
}
# generate baseline data if required and exposure proxy if this is not provided
if(!"infectiousness_proxy" %in% colnames(trial) &
baselineNumerator %in% colnames(trial) &
baselineDenominator %in% colnames(trial)) {
trial$infectiousness_proxy = trial[[baselineNumerator]]/trial[[baselineDenominator]]
} else {
if(generateBaseline) {
##############################################################################
# simulate baseline data with a specified ICC
# parameters of the spatial pattern of prevalence
initial_guess_bandwidth <- 0.0375/ICC_inp #bandwidth for KDE. The value of 0.0375 is from analysis of
# a sample of simulations based on Rusinga geography
# compute approximate diagonal of clusters
approx_diag = sqrt((max(trial$x)-min(trial$x))^2 + (max(trial$y)-min(trial$y))^2)/sqrt(length(unique(trial$cluster)))
# scale bandwidth by cluster diagonal
scaled_initial_guess = initial_guess_bandwidth/approx_diag
# number of positives required to match the specified prevalence
npositives = round(initialPrevalence*nrow(trial))
# For the smoothing step compute contributions to the relative effect size
# from other households as a function of distance to the other households
euclid <- distance_matrix(trial$x, trial$y)
bw = scaled_initial_guess*c(0.25,0.5,1,2,4)
iter = 0
deviation = 999
ICCs = c()
cat("Estimating the smoothing required to achieve the target ICC","\n")
while(abs(deviation) > tol){
iter=iter+1
#use a linear model fitted to log(bw) to estimate the required bandwidth
if(iter > 5){
lp = ICCs - ICC_inp
logbw_i = min(2,lm(formula = log(bw) ~ lp)$coefficients[1]) #impose a maximum on bw
bw = c(bw, exp(logbw_i))
}
#assign initial pattern
trial$infectiousness_proxy <- KDESmoother(trial$x,trial$y,kernnumber=200,bandwidth=bw[iter],low=0.0,high=1.0)
# Smooth the exposure proxy to allow for mosquito movement
# Note that the s.d. in each dimension of the 2 d gaussian is sd/sqrt(2)
# smoothedBaseline is the amount received by the each cluster from the contributions (infectiousness_proxy) of each source
smoothedBaseline <-  gauss(sd, euclid) %*% trial$infectiousness_proxy
# scale to input value of initial prevalence by assigning required number of infections with probabilities proportionate
# to infectiousness_proxy
positives = sample(x=nrow(trial),size=npositives,replace=FALSE,prob=smoothedBaseline)
trial$base_denom=1
trial$base_num=0
trial$base_num[positives]=1
baseline_analysis = Analyse_baseline(trial=trial,
baselineNumerator='base_num',
baselineDenominator='base_denom',
method='aovs',
ci.type=NULL)
ICC = baseline_analysis$estimates$ICC
ICCs = c(ICCs,ICC)
cat("bandwidth: ",bw[iter]*approx_diag,"  ICC=",ICC,"\n")
deviation = ICC - ICC_inp
}
}
}
# use contamination range if this is available
if (!is.null(theta_inp)){
sd = theta_inp/(sqrt(2)*qnorm(0.95))
}
if (is.null(sd)){
print('Error: contamination range or s.d. of spatial kernel must be provided')
trial = NULL
return(trial)
}
# generate baseline data if required and exposure proxy if this is not provided
if(!"infectiousness_proxy" %in% colnames(trial) &
baselineNumerator %in% colnames(trial) &
baselineDenominator %in% colnames(trial)) {
trial$infectiousness_proxy = trial[[baselineNumerator]]/trial[[baselineDenominator]]
} else {
if(generateBaseline) {
##############################################################################
# simulate baseline data with a specified ICC
# parameters of the spatial pattern of prevalence
initial_guess_bandwidth <- 0.0375/ICC_inp #bandwidth for KDE. The value of 0.0375 is from analysis of
# a sample of simulations based on Rusinga geography
# compute approximate diagonal of clusters
approx_diag = sqrt((max(trial$x)-min(trial$x))^2 + (max(trial$y)-min(trial$y))^2)/sqrt(length(unique(trial$cluster)))
# scale bandwidth by cluster diagonal
scaled_initial_guess = initial_guess_bandwidth/approx_diag
# number of positives required to match the specified prevalence
npositives = round(initialPrevalence*nrow(trial))
# For the smoothing step compute contributions to the relative effect size
# from other households as a function of distance to the other households
euclid <- distance_matrix(trial$x, trial$y)
bw = scaled_initial_guess*c(0.25,0.5,1,2,4)
iter = 0
deviation = 999
ICCs = c()
cat("Estimating the smoothing required to achieve the target ICC","\n")
while(abs(deviation) > tol){
iter=iter+1
#use a linear model fitted to log(bw) to estimate the required bandwidth
if(iter > 5){
lp = ICCs - ICC_inp
logbw_i = min(2,lm(formula = log(bw) ~ lp)$coefficients[1]) #impose a maximum on bw
bw = c(bw, exp(logbw_i))
}
#assign initial pattern
trial$infectiousness_proxy <- KDESmoother(trial$x,trial$y,kernnumber=200,bandwidth=bw[iter],low=0.0,high=1.0)
# Smooth the exposure proxy to allow for mosquito movement
# Note that the s.d. in each dimension of the 2 d gaussian is sd/sqrt(2)
# smoothedBaseline is the amount received by the each cluster from the contributions (infectiousness_proxy) of each source
smoothedBaseline <-  gauss(sd, euclid) %*% trial$infectiousness_proxy
# scale to input value of initial prevalence by assigning required number of infections with probabilities proportionate
# to infectiousness_proxy
positives = sample(x=nrow(trial),size=npositives,replace=FALSE,prob=smoothedBaseline)
trial$base_denom=1
trial$base_num=0
trial$base_num[positives]=1
baseline_analysis = Analyse_baseline(trial=trial,
baselineNumerator='base_num',
baselineDenominator='base_denom',
method='aovs',
ci.type=NULL)
ICC = baseline_analysis$estimates$ICC
ICCs = c(ICCs,ICC)
cat("bandwidth: ",bw[iter]*approx_diag,"  ICC=",ICC,"\n")
deviation = ICC - ICC_inp
}
}
}
# use contamination range if this is available
if (!is.null(theta_inp)){
sd = theta_inp/(sqrt(2)*qnorm(0.95))
}
if (is.null(sd)){
print('Error: contamination range or s.d. of spatial kernel must be provided')
trial = NULL
return(trial)
}
# generate baseline data if required and exposure proxy if this is not provided
if(!"infectiousness_proxy" %in% colnames(trial) &
baselineNumerator %in% colnames(trial) &
baselineDenominator %in% colnames(trial)) {
trial$infectiousness_proxy = trial[[baselineNumerator]]/trial[[baselineDenominator]]
} else {
if(generateBaseline) {
##############################################################################
# simulate baseline data with a specified ICC
# parameters of the spatial pattern of prevalence
initial_guess_bandwidth <- 0.0375/ICC_inp #bandwidth for KDE. The value of 0.0375 is from analysis of
# a sample of simulations based on Rusinga geography
# compute approximate diagonal of clusters
approx_diag = sqrt((max(trial$x)-min(trial$x))^2 + (max(trial$y)-min(trial$y))^2)/sqrt(length(unique(trial$cluster)))
# scale bandwidth by cluster diagonal
scaled_initial_guess = initial_guess_bandwidth/approx_diag
# number of positives required to match the specified prevalence
npositives = round(initialPrevalence*nrow(trial))
# For the smoothing step compute contributions to the relative effect size
# from other households as a function of distance to the other households
euclid <- distance_matrix(trial$x, trial$y)
bw = scaled_initial_guess*c(0.25,0.5,1,2,4)
iter = 0
deviation = 999
ICCs = c()
cat("Estimating the smoothing required to achieve the target ICC","\n")
while(abs(deviation) > tol){
iter=iter+1
#use a linear model fitted to log(bw) to estimate the required bandwidth
if(iter > 5){
lp = ICCs - ICC_inp
logbw_i = min(2,lm(formula = log(bw) ~ lp)$coefficients[1]) #impose a maximum on bw
bw = c(bw, exp(logbw_i))
}
#assign initial pattern
trial$infectiousness_proxy <- KDESmoother(trial$x,trial$y,kernnumber=200,bandwidth=bw[iter],low=0.0,high=1.0)
# Smooth the exposure proxy to allow for mosquito movement
# Note that the s.d. in each dimension of the 2 d gaussian is sd/sqrt(2)
# smoothedBaseline is the amount received by the each cluster from the contributions (infectiousness_proxy) of each source
smoothedBaseline <-  gauss(sd, euclid) %*% trial$infectiousness_proxy
# scale to input value of initial prevalence by assigning required number of infections with probabilities proportionate
# to infectiousness_proxy
positives = sample(x=nrow(trial),size=npositives,replace=FALSE,prob=smoothedBaseline)
trial$base_denom=1
trial$base_num=0
trial$base_num[positives]=1
baseline_analysis = Analyse_baseline(trial=trial,
baselineNumerator='base_num',
baselineDenominator='base_denom',
method='aovs',
ci.type=NULL)
ICC = baseline_analysis$estimates$ICC
ICCs = c(ICCs,ICC)
cat("bandwidth: ",bw[iter]*approx_diag,"  ICC=",ICC,"\n")
deviation = ICC - ICC_inp
}
}
}
# use contamination range if this is available
if (!is.null(theta_inp)){
sd = theta_inp/(sqrt(2)*qnorm(0.95))
}
if (is.null(sd)){
print('Error: contamination range or s.d. of spatial kernel must be provided')
trial = NULL
return(trial)
}
# generate baseline data if required and exposure proxy if this is not provided
if(!"infectiousness_proxy" %in% colnames(trial) &
baselineNumerator %in% colnames(trial) &
baselineDenominator %in% colnames(trial)) {
trial$infectiousness_proxy = trial[[baselineNumerator]]/trial[[baselineDenominator]]
} else {
if(generateBaseline) {
##############################################################################
# simulate baseline data with a specified ICC
# parameters of the spatial pattern of prevalence
initial_guess_bandwidth <- 0.0375/ICC_inp #bandwidth for KDE. The value of 0.0375 is from analysis of
# a sample of simulations based on Rusinga geography
# compute approximate diagonal of clusters
approx_diag = sqrt((max(trial$x)-min(trial$x))^2 + (max(trial$y)-min(trial$y))^2)/sqrt(length(unique(trial$cluster)))
# scale bandwidth by cluster diagonal
scaled_initial_guess = initial_guess_bandwidth/approx_diag
# number of positives required to match the specified prevalence
npositives = round(initialPrevalence*nrow(trial))
# For the smoothing step compute contributions to the relative effect size
# from other households as a function of distance to the other households
euclid <- distance_matrix(trial$x, trial$y)
bw = scaled_initial_guess*c(0.25,0.5,1,2,4)
iter = 0
deviation = 999
ICCs = c()
cat("Estimating the smoothing required to achieve the target ICC","\n")
while(abs(deviation) > tol){
iter=iter+1
#use a linear model fitted to log(bw) to estimate the required bandwidth
if(iter > 5){
lp = ICCs - ICC_inp
logbw_i = min(2,lm(formula = log(bw) ~ lp)$coefficients[1]) #impose a maximum on bw
bw = c(bw, exp(logbw_i))
}
#assign initial pattern
trial$infectiousness_proxy <- KDESmoother(trial$x,trial$y,kernnumber=200,bandwidth=bw[iter],low=0.0,high=1.0)
# Smooth the exposure proxy to allow for mosquito movement
# Note that the s.d. in each dimension of the 2 d gaussian is sd/sqrt(2)
# smoothedBaseline is the amount received by the each cluster from the contributions (infectiousness_proxy) of each source
smoothedBaseline <-  gauss(sd, euclid) %*% trial$infectiousness_proxy
# scale to input value of initial prevalence by assigning required number of infections with probabilities proportionate
# to infectiousness_proxy
positives = sample(x=nrow(trial),size=npositives,replace=FALSE,prob=smoothedBaseline)
trial$base_denom=1
trial$base_num=0
trial$base_num[positives]=1
baseline_analysis = Analyse_baseline(trial=trial,
baselineNumerator='base_num',
baselineDenominator='base_denom',
method='aovs',
ci.type=NULL)
ICC = baseline_analysis$estimates$ICC
ICCs = c(ICCs,ICC)
cat("bandwidth: ",bw[iter]*approx_diag,"  ICC=",ICC,"\n")
deviation = ICC - ICC_inp
}
}
}
# use contamination range if this is available
if (!is.null(theta_inp)){
sd = theta_inp/(sqrt(2)*qnorm(0.95))
}
if (is.null(sd)){
print('Error: contamination range or s.d. of spatial kernel must be provided')
trial = NULL
return(trial)
}
initial_guess_bandwidth <- 0.0375/ICC_inp #bandwidth for KDE. The value of 0.0375 is from analysis of
# compute approximate diagonal of clusters
approx_diag = sqrt((max(trial$x)-min(trial$x))^2 + (max(trial$y)-min(trial$y))^2)/sqrt(length(unique(trial$cluster)))
# scale bandwidth by cluster diagonal
scaled_initial_guess = initial_guess_bandwidth/approx_diag
# number of positives required to match the specified prevalence
npositives = round(initialPrevalence*nrow(trial))
test_Simulate_CRT=Simulate_CRT(theta_inp=1.2,initialPrevalence=0.4)
initialPrevalence=0.4
# use contamination range if this is available
if (!is.null(theta_inp)){
sd = theta_inp/(sqrt(2)*qnorm(0.95))
}
if (is.null(sd)){
print('Error: contamination range or s.d. of spatial kernel must be provided')
trial = NULL
return(trial)
}
initial_guess_bandwidth <- 0.0375/ICC_inp #bandwidth for KDE. The value of 0.0375 is from analysis of
test_Simulate_CRT=Simulate_CRT(theta_inp=1.2,initialPrevalence=0.4,ICC_inp=0.05)
test_Simulate_CRT=Simulate_CRT(trial=NULLCRTspillover::test_AvecNet$assignments,theta_inp=1.2,initialPrevalence=0.4,ICC_inp=0.05,efficacy=0.2)
test_Simulate_CRT=Simulate_CRT(trial=CRTspillover::test_AvecNet$assignments,theta_inp=1.2,initialPrevalence=0.4,ICC_inp=0.05,efficacy=0.2)
library(CRTspillover)
head(test_Simulate_CRT)
Plot_CRTmap(test_Simulate_CRT)
Analyse_CRT(test_Simulate_CRT,method='ML')
junkML=Analyse_CRT(test_Simulate_CRT,method='ML')
Plot_Contamination(junkML)
junk=Simulate_CRT(trial=CRTspillover::test_AvecNet$assignments,theta_inp=1.2,initialPrevalence=0.4,ICC_inp=0.05,efficacy=0.5)
Analyse_CRT(junk,method='ML')
junkML=Analyse_CRT(junk,method='ML')
Plot_Contamination(junkML)
junkSPDE=Analyse_CRT(junk,method='SPDE')
usethis::use_package("Matrix")
junkSPDE=Analyse_CRT(junk,method='SPDE')
library(CRTspillover)
junkSPDE=Analyse_CRT(junk,method='SPDE')
library(CRTspillover)
junkSPDE=Analyse_CRT(junk,method='SPDE')
library(CRTspillover)
junkSPDE=Analyse_CRT(junk,method='SPDE')
View(junk)
Plot_Contamination(junkSPDE)
Plot_CRTmap(trial=junk,analysis=junkSPDE,showDistance = TRUE)
Plot_CRTmap(trial=junk,analysis=junkSPDE,showProportion = TRUE)
Plot_CRTmap(trial=junk,analysis=junkSPDE,showProportion = TRUE,maskbuffer = 0.2)
devtools::document()
library(CRTspillover)
library(CRTspillover)
Design_CRT(coordinates=test_site, ICC=0.10, effect=0.4, pC=0.35, cont=0.5, h=100)
junkb = Design_CRT(coordinates=test_site, ICC=0.10, effect=0.4, pC=0.35, cont=0.5, h=100)
junkb = Design_CRT(coordinates=test_site, ICC=0.10, effect=0.4, pC=0.35, cont=0.5, h=20)
head(junkb)
head(junkb$trial)
head(junkb$assignments)
Plot_CRTmap(junkb$assignments)
browseVignettes(package="CRTspillover")
browseVignettes(package="CRTspillover")
devtools::install(dependencies = TRUE, build_vignettes = TRUE)
devtools::install(dependencies = TRUE, build_vignettes = TRUE)
devtools::install(dependencies = TRUE, build_vignettes = TRUE)
library(CRTspillover)
test_AvecNet = Design_CRT()
save(test_AvecNet,test_AvecNet.RData)
save(test_AvecNet,file='data/test_AvecNet.RData')
library(CRTspillover)
test_AvecNet = Design_CRT()
save(test_AvecNet,file='data/test_AvecNet.RData')
getwd()
set.seed(1234)
test_AvecNet = Design_CRT()
save(test_AvecNet,file='data/test_AvecNet.RData')
set.seed(1234)
test_Simulate_CRT =Simulate_CRT(trial=CRTspillover::test_AvecNet$assignments,
theta_inp=1.2,
initialPrevalence=0.4,
ICC_inp=0.05,efficacy=0.2)
save(test_Simulate_CRT,file='data/test_Simulate_CRT.RData')
library(CRTspillover)
library(CRTspillover)
library(CRTspillover)
head(test_Simulate_CRT)
sum(test_Simulate_CRT$num)
sum(test_Simulate_CRT$base_num)
set.seed(1234)
test_Simulate_CRT =Simulate_CRT(trial=CRTspillover::test_AvecNet$assignments,
theta_inp=1.2,
initialPrevalence=0.4,
ICC_inp=0.05,efficacy=0.2)
save(test_Simulate_CRT,file='data/test_Simulate_CRT.RData')
devtools::document()
