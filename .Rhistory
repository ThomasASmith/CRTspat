# calculation of the simplicial depth and
# the half space depth
# u and v are the coordinates of the arbitrary point
u <- X[["x"]]
v <- X[["y"]]
# for the CRT application, consider only the arm within which the point is located
trial <- trial[trial$arm == X[[arm]],]
n <- nrow(trial)
x <- trial$x
y <- trial$y
nums <- 0
numh <- 0
sdep <- 0  # simplicial depth
hdep <- 0  # half-space depth
eps <- 1e-06
nt <- 0
# construct the vector alpha
alpha <- fval <- rep(NA, nrow(trial))
for (i in 1:n) {
d <- sqrt((x[i] - u) * (x[i] - u) + (y[i] - v) * (y[i] - v))
if (d <= eps) {
nt <- nt + 1
} else {
xu <- (x[i] - u)/d
yu <- (y[i] - v)/d
if (abs(xu) > abs(yu)) {
if (x[i] >= u) {
alpha[i - nt] <- asin(yu)
if (alpha[i - nt] < 0.0) {
alpha[i - nt] <- 2 * pi + alpha[i - nt]
}
} else {
alpha[i - nt] <- pi - asin(yu)
}
} else {
if (y[i] >= v) {
alpha[i - nt] <- acos(xu)
} else {
alpha[i - nt] <- 2 * pi - acos(xu)
}
}
if (alpha[i - nt] >= (2 * pi - eps)) alpha[i - nt] <- 0.0
}
}
nn <- n - nt
if (nn > 1) {
# nn is the number of elements of alpha that have been assigned a value
# the missing elements should be removed
#call sort (alpha, nn)
alpha <- alpha[!is.na(alpha)]
alpha <- alpha[order(alpha)]
# check whether theta=(u,v) lies outside the data cloud
angle <- alpha[1] - alpha[nn] + 2 * pi
for (i in 2:nn) {
angle <- max(angle, (alpha[i] - alpha[i - 1]))
}
if (angle <= (pi + eps)) {
# make smallest alpha equal to zero, and compute nu = number of alpha < pi
angle <- alpha[1]
nu <- 0
for (i in 1:nn) {
alpha[i] <- alpha[i] - angle
if (alpha[i] < (pi - eps)) nu <- nu + 1
}
if (nu < nn) {
# merge sort the alpha with their antipodal angles beta, and at the same time
# update i,fval[i], and nbad
ja <- 1
jb <- 1
alphk <- alpha[1]
betak <- alpha[nu + 1] - pi
nn2 <- nn * 2
nbad <- 0
i <- nu
nf <- nn
for (j in 1:nn2) {
if ((alphk + eps) < betak) {
nf <- nf + 1
if (ja < nn) {
ja <- ja + 1
alphk <- alpha[ja]
} else {
alphk <- 2 * pi + 1
}
} else {
i <- i + 1
if (identical(i,(nn + 1))) {
i <- 1
nf <- nf - nn
}
fval[i] <- nf
nbad <- nbad + k((nf - i), 2)
if (jb < nn) {
jb <- jb + 1
if ((jb + nu) <= nn) {
betak <- alpha[jb + nu] - pi
} else {
betak <- alpha[jb + nu - nn] + pi
}
} else {
betak <- 2 * pi + 1.0
}
}
}
nums <- k(nn, 3) - nbad
# computation of numh for half space depth
gi <- 0
ja <- 1
angle <- alpha[1]
numh <- min(fval[1], (nn - fval[1]))
for (i in 2:nn) {
if (alpha[i] <= (angle + eps)) {
ja <- ja + 1
} else {
gi <- gi + ja
ja <- 1
angle <- alpha[i]
}
ki <- fval[i] - gi
numh <- min(numh, min(ki, (nn - ki)))
}
# adjust for the number nt of datapoints equal to theta
}
}
}
nums <- nums + k(nt, 1) * k(nn, 2) + k(nt, 2) * k(nn, 1) + k(nt, 3)
if (n >= 3) sdep <- nums/k(n, 3)
numh <- numh + nt
hdep <- numh/n
depths <- list(numh = numh, hdep = hdep, sdep = sdep)
}
junk <- apply(trial, MARGIN = 2, FUN = depths(), trial = trial)
junk <- apply(trial, MARGIN = 2, FUN = depths, trial = trial)
junk <- apply(trial, MARGIN = 1, FUN = depths, trial = trial)
junk <- apply(trial, MARGIN = 2, FUN = depths, trial = trial)
junk <- apply(trial, MARGIN = 1, FUN = depths, trial = trial)
depths <- function(X, trial) {
# this is an R translation of the fortran code in
# Rousseeuw & Ruts https://www.jstor.org/stable/2986073
# algorithm as 307.1 Appl.Statist. (1996), vol.45, no.4
# calculation of the simplicial depth and
# the half space depth
# u and v are the coordinates of the arbitrary point
u <- X[["x"]]
v <- X[["y"]]
# for the CRT application, consider only the arm within which the point is located
trial <- trial[trial$arm == X[["arm"]],]
n <- nrow(trial)
x <- trial$x
y <- trial$y
nums <- 0
numh <- 0
sdep <- 0  # simplicial depth
hdep <- 0  # half-space depth
eps <- 1e-06
nt <- 0
# construct the vector alpha
alpha <- fval <- rep(NA, nrow(trial))
for (i in 1:n) {
d <- sqrt((x[i] - u) * (x[i] - u) + (y[i] - v) * (y[i] - v))
if (d <= eps) {
nt <- nt + 1
} else {
xu <- (x[i] - u)/d
yu <- (y[i] - v)/d
if (abs(xu) > abs(yu)) {
if (x[i] >= u) {
alpha[i - nt] <- asin(yu)
if (alpha[i - nt] < 0.0) {
alpha[i - nt] <- 2 * pi + alpha[i - nt]
}
} else {
alpha[i - nt] <- pi - asin(yu)
}
} else {
if (y[i] >= v) {
alpha[i - nt] <- acos(xu)
} else {
alpha[i - nt] <- 2 * pi - acos(xu)
}
}
if (alpha[i - nt] >= (2 * pi - eps)) alpha[i - nt] <- 0.0
}
}
nn <- n - nt
if (nn > 1) {
# nn is the number of elements of alpha that have been assigned a value
# the missing elements should be removed
#call sort (alpha, nn)
alpha <- alpha[!is.na(alpha)]
alpha <- alpha[order(alpha)]
# check whether theta=(u,v) lies outside the data cloud
angle <- alpha[1] - alpha[nn] + 2 * pi
for (i in 2:nn) {
angle <- max(angle, (alpha[i] - alpha[i - 1]))
}
if (angle <= (pi + eps)) {
# make smallest alpha equal to zero, and compute nu = number of alpha < pi
angle <- alpha[1]
nu <- 0
for (i in 1:nn) {
alpha[i] <- alpha[i] - angle
if (alpha[i] < (pi - eps)) nu <- nu + 1
}
if (nu < nn) {
# merge sort the alpha with their antipodal angles beta, and at the same time
# update i,fval[i], and nbad
ja <- 1
jb <- 1
alphk <- alpha[1]
betak <- alpha[nu + 1] - pi
nn2 <- nn * 2
nbad <- 0
i <- nu
nf <- nn
for (j in 1:nn2) {
if ((alphk + eps) < betak) {
nf <- nf + 1
if (ja < nn) {
ja <- ja + 1
alphk <- alpha[ja]
} else {
alphk <- 2 * pi + 1
}
} else {
i <- i + 1
if (identical(i,(nn + 1))) {
i <- 1
nf <- nf - nn
}
fval[i] <- nf
nbad <- nbad + k((nf - i), 2)
if (jb < nn) {
jb <- jb + 1
if ((jb + nu) <= nn) {
betak <- alpha[jb + nu] - pi
} else {
betak <- alpha[jb + nu - nn] + pi
}
} else {
betak <- 2 * pi + 1.0
}
}
}
nums <- k(nn, 3) - nbad
# computation of numh for half space depth
gi <- 0
ja <- 1
angle <- alpha[1]
numh <- min(fval[1], (nn - fval[1]))
for (i in 2:nn) {
if (alpha[i] <= (angle + eps)) {
ja <- ja + 1
} else {
gi <- gi + ja
ja <- 1
angle <- alpha[i]
}
ki <- fval[i] - gi
numh <- min(numh, min(ki, (nn - ki)))
}
# adjust for the number nt of datapoints equal to theta
}
}
}
nums <- nums + k(nt, 1) * k(nn, 2) + k(nt, 2) * k(nn, 1) + k(nt, 3)
if (n >= 3) sdep <- nums/k(n, 3)
numh <- numh + nt
hdep <- numh/n
depths <- list(numh = numh, hdep = hdep, sdep = sdep)
}
junk <- apply(trial, MARGIN = 1, FUN = depths, trial = trial)
depths <- function(X, trial) {
# this is an R translation of the fortran code in
# Rousseeuw & Ruts https://www.jstor.org/stable/2986073
# algorithm as 307.1 Appl.Statist. (1996), vol.45, no.4
# calculation of the simplicial depth and
# the half space depth
# u and v are the coordinates of the arbitrary point
u <- as.numeric(X[["x"]])
v <- as.numeric(X[["y"]])
# for the CRT application, consider only the arm within which the point is located
trial <- trial[trial$arm == X[["arm"]],]
n <- nrow(trial)
x <- trial$x
y <- trial$y
nums <- 0
numh <- 0
sdep <- 0  # simplicial depth
hdep <- 0  # half-space depth
eps <- 1e-06
nt <- 0
# construct the vector alpha
alpha <- fval <- rep(NA, nrow(trial))
for (i in 1:n) {
d <- sqrt((x[i] - u) * (x[i] - u) + (y[i] - v) * (y[i] - v))
if (d <= eps) {
nt <- nt + 1
} else {
xu <- (x[i] - u)/d
yu <- (y[i] - v)/d
if (abs(xu) > abs(yu)) {
if (x[i] >= u) {
alpha[i - nt] <- asin(yu)
if (alpha[i - nt] < 0.0) {
alpha[i - nt] <- 2 * pi + alpha[i - nt]
}
} else {
alpha[i - nt] <- pi - asin(yu)
}
} else {
if (y[i] >= v) {
alpha[i - nt] <- acos(xu)
} else {
alpha[i - nt] <- 2 * pi - acos(xu)
}
}
if (alpha[i - nt] >= (2 * pi - eps)) alpha[i - nt] <- 0.0
}
}
nn <- n - nt
if (nn > 1) {
# nn is the number of elements of alpha that have been assigned a value
# the missing elements should be removed
#call sort (alpha, nn)
alpha <- alpha[!is.na(alpha)]
alpha <- alpha[order(alpha)]
# check whether theta=(u,v) lies outside the data cloud
angle <- alpha[1] - alpha[nn] + 2 * pi
for (i in 2:nn) {
angle <- max(angle, (alpha[i] - alpha[i - 1]))
}
if (angle <= (pi + eps)) {
# make smallest alpha equal to zero, and compute nu = number of alpha < pi
angle <- alpha[1]
nu <- 0
for (i in 1:nn) {
alpha[i] <- alpha[i] - angle
if (alpha[i] < (pi - eps)) nu <- nu + 1
}
if (nu < nn) {
# merge sort the alpha with their antipodal angles beta, and at the same time
# update i,fval[i], and nbad
ja <- 1
jb <- 1
alphk <- alpha[1]
betak <- alpha[nu + 1] - pi
nn2 <- nn * 2
nbad <- 0
i <- nu
nf <- nn
for (j in 1:nn2) {
if ((alphk + eps) < betak) {
nf <- nf + 1
if (ja < nn) {
ja <- ja + 1
alphk <- alpha[ja]
} else {
alphk <- 2 * pi + 1
}
} else {
i <- i + 1
if (identical(i,(nn + 1))) {
i <- 1
nf <- nf - nn
}
fval[i] <- nf
nbad <- nbad + k((nf - i), 2)
if (jb < nn) {
jb <- jb + 1
if ((jb + nu) <= nn) {
betak <- alpha[jb + nu] - pi
} else {
betak <- alpha[jb + nu - nn] + pi
}
} else {
betak <- 2 * pi + 1.0
}
}
}
nums <- k(nn, 3) - nbad
# computation of numh for half space depth
gi <- 0
ja <- 1
angle <- alpha[1]
numh <- min(fval[1], (nn - fval[1]))
for (i in 2:nn) {
if (alpha[i] <= (angle + eps)) {
ja <- ja + 1
} else {
gi <- gi + ja
ja <- 1
angle <- alpha[i]
}
ki <- fval[i] - gi
numh <- min(numh, min(ki, (nn - ki)))
}
# adjust for the number nt of datapoints equal to theta
}
}
}
nums <- nums + k(nt, 1) * k(nn, 2) + k(nt, 2) * k(nn, 1) + k(nt, 3)
if (n >= 3) sdep <- nums/k(n, 3)
numh <- numh + nt
hdep <- numh/n
depths <- list(numh = numh, hdep = hdep, sdep = sdep)
}
junk <- apply(trial, MARGIN = 1, FUN = depths, trial = trial)
View(junk)
jun1 <- data.frame(junk)
View(jun1)
junk <- lapply(trial, MARGIN = 1, FUN = depths, trial = trial)
junk <- lapply(trial, FUN = depths, trial = trial)
junk <- sapply(trial, FUN = depths, trial = trial)
junk_df <- as.data.frame(do.call(rbind, lapply(junk, as.data.frame)))
View(junk_df)
dist <- matrix(data = runif(0,5), nrow=4, ncol=4)
dist
dist <- matrix(runif(0,5), nrow=4, ncol=4)
dist
dist <- matrix(rep(runif(0,5),16), nrow=4, ncol=4)
dist
dist <- rep(runif(0,5),16)
dist <- matrix(dist, nrow=4, ncol=4)
dist
dist <- rep(runif(0,5),16)
dist
dist <- rep(runif(0,5),times=16)
dist
runif(0,5)
? runif
dist <- matrix(runif(16, 0,5), nrow=4, ncol=4)
dist
arm = c('control', 'intervention','intervention','control')
rowsums(arm=='intervention' & dist < 2)
rowSums(arm=='intervention' & dist < 2)
rowSums(arm=='intervention')
arm=='intervention' & dist < 2
arm=='intervention' & dist < 5
colSums(arm=='intervention' & dist < 2)
dist
arm
devtools::document()
? compute_distance()
devtools::document()
exampletrial <- compute_distance(trial = readdata('exampleCRT.txt'), measure = 'disc', radius = 1.0)
exampletrial <- compute_distance(trial = readdata('exampleCRT.txt'), measure = 'disc', radius = 1.0)
library(CRTspat)
library(CRTspat)
devtools::document()
exampletrial <- compute_distance(trial = readdata('exampleCRT.txt'), measure = 'disc', radius = 1.0)
library(CRTspat)
exampletrial <- compute_distance(trial = readdata('exampleCRT.txt'), measure = 'disc', radius = 1.0)
exampletrial <- compute_distance(trial = readdata('exampleCRT.txt'), measure = 'nearestDiscord', radius = 1.0)
exampletrial <- compute_distance(trial = readdata('exampleCRT.txt'), measure = 'nearestDiscord', radius = 0.5)
View(exampletrial)
exampletrial <- compute_distance(trial = readdata('exampleCRT.txt'), measure = 'disc', radius = 1.0)
exampletrial <- compute_distance(trial = readdata('exampleCRT.txt'), measure = 'disc', radius = 0.5)
with(exampletrial$trial,plot(nearestDiscord,disc))
exampletrial <- compute_distance(trial = readdata('exampleCRT.txt'), measure = 'sdep', radius = 0.5)
with(exampletrial$trial,plot(nearestDiscord,sdep))
head(exampletrial$trial)
with(exampletrial$trial,plot(nearestDiscord,sdep))
library(CRTspat)
exampletrial <- compute_distance(trial = readdata('exampleCRT.txt'), measure = 'sdep', radius = 0.5)
with(exampletrial$trial,plot(nearestDiscord,sdep))
with(exampletrial$trial,plot(nearestDiscord,hdep))
with(exampletrial$trial,plot(sdep,hdep))
exampletrial <- compute_distance(trial = exampletrial, measure = 'disc', radius = 0.5)
with(exampletrial$trial,plot(disc,hdep))
with(exampletrial$trial,plot(nearestDiscord,disc))
library(CRTspat)
exampleCRT <- randomizeCRT(trial = readdata('exampleCRT.txt'), matchedPair = TRUE)
exampleCRT <- randomizeCRT(trial = readdata('exampleCRT.txt'), matchedPair = TRUE)
trial$arm <- factor(arm[trial$cluster[]], levels = c(0, 1), labels = c("control",
"intervention"))
exampleCRT <- randomizeCRT(trial = readdata('exampleCRT.txt'), matchedPair = TRUE)
library(CRTspat)
test_Clusters <- specify_clusters(readdata("example_site.csv"),h = 50)
test_simulateCRT <- simulateCRT(trial = test_Arms,
theta_inp = 1.2,outcome0 = 0.4,
ICC_inp = 0.05 ,effect = 0.4, tol = 0.05)
test_Arms <- randomizeCRT(trial = test_Clusters,matchedPair = TRUE)
library(CRTspat)
library(CRTspat)
library(CRTspat)
{exampleCRT <- readdata('exampleCRT.txt')
simulation <- simulateCRT(exampleCRT,
effect = 0.25,
ICC_inp = 0.05,
outcome0 = 0.5,
matchedPair = FALSE,
scale = 'proportion',
sd = 0.6,
tol = 0.05)
summary(simulation) }
test_Clusters <- specify_clusters(readdata("example_site.csv"),h = 50)
test_Arms <- randomizeCRT(trial = test_Clusters,matchedPair = TRUE)
test_Arms <- randomizeCRT(trial = test_Clusters,matchedPair = TRUE)
test_Arms <- randomizeCRT(trial = test_Clusters,matchedPair = TRUE)
test_Arms <- randomizeCRT(trial = test_Clusters,matchedPair = TRUE)
test_Arms <- randomizeCRT(trial = test_Clusters,matchedPair = TRUE)
head(trial)
library(CRTspat)
library(CRTspat)
library(CRTspat)
test_Clusters <- specify_clusters(readdata("example_site.csv"),h = 50)
test_Arms <- randomizeCRT(trial = test_Clusters,matchedPair = TRUE)
test_Arms <- randomizeCRT(trial = test_Clusters,matchedPair = TRUE)
test_Arms <- randomizeCRT(trial = test_Clusters,matchedPair = TRUE)
test_Arms <- randomizeCRT(trial = test_Clusters,matchedPair = TRUE)
library(CRTspat)
