readdata <- function(filename) {
fname <- eval(filename)
extdata <- system.file("extdata",package = 'CRTspillover')
if (unlist(gregexpr('.txt', fname)) > 0) robject <- dget(file = paste0(extdata,'/',fname))
if (unlist(gregexpr('.csv', fname)) > 0) robject <- read.csv(file = paste0(extdata,'/',fname),
row.names = FALSE)
return(robject)
}
trial=readdata('testClusters.csv')
remove(readdata)
example_simulated_CRT =  Simulate_CRT(trial=readdata('testArms.csv'),
efficacy=0.25,
ICC_inp=0.05,
initialPrevalence=0.5,
matchedPair = TRUE,
sd=0.6,
tol=0.05)
Analyse_CRT(trial = example_simulated_CRT,method='GEE')
library(CRTspillover)
? CRTspillover
exampletrial <- Specify_CRTbuffer(testArms, bufferWidth = 0.2)
head(exampletrial)
example_locations <- readdata('example_baseline.csv')
write.csv(Solarmal_baseline, file = 'inst/extdata/example_baseline.csv', row.names = FALSE)
getwd
getwd()
write.csv(Solarmal_baseline, file = 'example_baseline.csv', row.names = FALSE)
devtools::document()
library(CRTspillover)
R CMD build --resave-data
build --resave-data
library(CRTspillover)
Solarmal_baseline <- read.csv(file = paste0(extdata,"/Solarmal_baseline.csv"))
extdata <- system.file("extdata",package = 'CRTspillover')
Solarmal_baseline <- read.csv(file = paste0(extdata,"/Solarmal_baseline.csv"))
testLocationsxy <- Convert_LatLong(Solarmal_baseline) #test_site is simulated
testClusters <- DefineClusters(testLocationsxy,h = 50)
testArms <- Randomize_CRT(trial = testClusters,matchedPair = TRUE)
test_Simulate_CRT <- Simulate_CRT(trial = testArms,
theta_inp = 1.2,initialPrevalence = 0.4,
ICC_inp = 0.05,efficacy = 0.4,tol = 0.05)
test_Simulate_CRT$cluster <- as.numeric(test_Simulate_CRT$cluster)
test_Simulate_CRT$arm <- as.character(test_Simulate_CRT$arm)
rownames(test_Simulate_CRT) <- NULL
junk <- read.csv(file = paste0(extdata,"/test_Simulate_CRT.csv"))
View(junk)
View(test_Simulate_CRT)
View(junk)
View(junk)
test_Simulate_CRT$RDT_test_result <- NULL
rownames(test_Simulate_CRT) <- NULL
test_Simulate_CRT$X <- NULL
Plot_CRTmap(junk)
Plot_CRTmap(test_Simulate_CRT)
save(junk,file = 'test_Simulate_CRT1.csv')
write.csv(junk,file = 'test_Simulate_CRT1.csv',row.names = FALSE)
write.csv(test_Simulate_CRT,file = 'test_Simulate_CRT1.csv',row.names = FALSE)
test_Simulate_CRT
set.seed(1234)
test_Simulate_CRT <- get_test3(extdata)
get_test3 = function(extdata){
Solarmal_baseline <- read.csv(file = paste0(extdata,"/Solarmal_baseline.csv"))
testLocationsxy <- Convert_LatLong(Solarmal_baseline) #test_site is simulated
testClusters <- DefineClusters(testLocationsxy,h = 50)
testArms <- Randomize_CRT(trial = testClusters,matchedPair = TRUE)
test_Simulate_CRT <- Simulate_CRT(trial = testArms,
theta_inp = 1.2,initialPrevalence = 0.4,
ICC_inp = 0.05,efficacy = 0.4,tol = 0.05)
test_Simulate_CRT$cluster <- as.numeric(test_Simulate_CRT$cluster)
test_Simulate_CRT$arm <- as.character(test_Simulate_CRT$arm)
test_Simulate_CRT$RDT_test_result <- NULL
test_Simulate_CRT$X <- NULL
rownames(test_Simulate_CRT) <- NULL
return(test_Simulate_CRT)}
test_Simulate_CRT <- get_test3(extdata)
write.csv(test_Simulate_CRT,file = 'test_Simulate_CRT1.csv',row.names = FALSE)
library(CRTspillover)
library(CRTspillover)
example5 <- readdata("test_Simulate_CRT1.csv")
example5$num <- example5$denom <- NULL
example5a <- Simulate_CRT(trial = example5,
efficacy = 0.4,
initialPrevalence = 0.5,
generateBaseline = FALSE,
baselineNumerator = "base_num",
baselineDenominator = "base_denom",
ICC_inp = NULL, theta_inp = 0.8)
inlaMeshTest <- createMesh(example5a, ncells=100)
save(inlaMeshTest, file = 'data/inlaMeshTest.Rdata')
library(CRTspillover)
results6a <- Analyse_CRT(trial = example5a, method = 'INLA', inla.mesh = inlaMeshTest)
Plot_CRTmap(trial = results6a, showPrediction = TRUE)
Plot_CRTmap(trial = example5a, analysis = results6a, showPrediction = TRUE)
Plot_Contamination(results6a)
View(results6a)
Plot_CRTmap(trial = results6a, showDistance = TRUE)
Plot_CRTmap(trial = example5a, analysis = results6a, showDistance = TRUE)
devtools::load_all(".")
results6a <- Analyse_CRT(trial = example5a, method = 'INLA', inla.mesh = inlaMeshTest)
junk <- inla.result$summary.linear.predictor[index, "0.5quant"]
summary(junk)
formula
View(inla.result)
junk <- inla.mesh$prediction$pvar[index, "0.5quant"]
summary(inla.mesh$prediction$pvar)
eval(parse(text = FUN))
eval(parse(text = FUN))
x
x
x <- inla.mesh$prediction$nearestDiscord * exp(beta2)
inla.mesh$prediction$pvar <- ifelse(
cfunc == "X", rep(NA, nrow(inla.mesh$prediction)),
eval(parse(text = FUN))
)
effectsp$df$pvar <- inla.mesh$prediction$pvar
Plot_CRTmap(trial = example5a, analysis = results6a, showPrediction = TRUE)
View(results6a)
library(CRTspillover)
example5 <- readdata("test_Simulate_CRT1.csv")
example5$num <- example5$denom <- NULL
example5a <- Simulate_CRT(trial = example5,
efficacy = 0.4,
initialPrevalence = 0.5,
generateBaseline = FALSE,
baselineNumerator = "base_num",
baselineDenominator = "base_denom",
ICC_inp = NULL, theta_inp = 0.8)
#inlaMeshTest <- createMesh(example5a, ncells=100)
results6a <- Analyse_CRT(trial = example5a, method = 'INLA', inla.mesh = inlaMeshTest)
#inlaMeshTest <- createMesh(example5a, ncells=100)
results6a <- Analyse_CRT(trial = example5a, method = 'INLA', inla.mesh = inlaMeshTest)
summary(trial$pvar)
summary(trial$pvar)
summary(inla.mesh$prediction$pvar)
summary(x)
summary(eval(parse(text = FUN))
)
summary(inla.mesh$prediction$pvar)
cfunc
Plot_CRTmap(trial = example5a, analysis = results6a, showPrediction = TRUE)
library(CRTspillover)
#inlaMeshTest <- createMesh(example5a, ncells=100)
results6a <- Analyse_CRT(trial = example5a, method = 'INLA', inla.mesh = inlaMeshTest)
Plot_CRTmap(trial = example5a, analysis = results6a, showPrediction = TRUE)
Plot_CRTmap(trial = example5a, analysis = results6a, showDistance = TRUE)
Plot_Contamination(results6a)
library(CRTspillover)
library(CRTspillover)
library(CRTspillover)
usethis::use_import_from(package='stats', fun= 'gaussian')
usethis::use_import_from(package='stats', fun= 'gaussian')
usethis::use_import_from(package='stats', fun= 'gaussian')
usethis::use_import_from(package='stats', fun= 'poisson')
usethis::use_import_from(package='stats', fun= 't.test')
usethis::use_package("jagsUI")
usethis::use_import_from(package='jagsUI', fun= 'autojags')
library(CRTspillover)
library(CRTspillover)
example5 <- readdata("test_Simulate_CRT1.csv")
example5 <- readdata("test_Simulate_CRT1.csv")
example5$num <- example5$denom <- NULL
example5a <- Simulate_CRT(trial = example5,
efficacy = 0.4,
initialPrevalence = 0.5,
generateBaseline = FALSE,
baselineNumerator = "base_num",
baselineDenominator = "base_denom",
ICC_inp = NULL, theta_inp = 0.8)
results6b <- Analyse_CRT(trial = example5a, method = 'MCMC')
initialTheta <- qnorm(1-alpha,sd = sqrt(2*sd^2))/(1-2*alpha)*c(1/4,4)
alpha
sd
sd = 0.5
initialTheta <- qnorm(1-alpha,sd = sqrt(2*sd^2))/(1-2*alpha)*c(1/4,4)
datajags<-with(trial,list(alpha=alpha,cluster=cluster,num=num,denom=denom,d=nearestDiscord,N=nrow(trial),ncluster=max(cluster),initialTheta=initialTheta))
datajags<-with(trial,list(alpha=alpha,cluster=cluster,num=num,denom=denom,d=nearestDiscord,N=nrow(trial),
ncluster=max(as.numeric(as.character(cluster))),initialTheta=initialTheta))
max(as.numeric(as.character(cluster)))
datajags$ncluster
# construct the rjags code by concatenating strings: text1 and text3 are model independent
#
#  "model{
#    for(i in 1:N){
#      num[i] ~ dbin(p[i],denom[i]) #every datapoint is drawn from a Binomial distribution with probability p
text1 = "model{\n for(i in 1:N){\n num[i] ~ dbin(p[i],denom[i]) \n"
text1 = "model{\n
for(i in 1:N){\n
num[i] ~ dbin(p[i],denom[i]) \n"
#      < text2: model excluding random effect is inserted here >
#   model for fixed effects
text2 = switch(cfunc,
'S' = "fixedp[i] <- ifelse(d[i] < -beta,pC,ifelse(d[i] > beta,pI,pI + (pC - pI) * (beta2 - d[i])/(2*beta)))\n",
'P' = "fixedp[i] <- pI + (pC-pI)*pnorm(-d[i],0,beta) \n",
'L' = "fixedp[i] <- pI + (pC-pI)/(1 + exp(beta*d[i])) \n")
cfunc
text3 = "logitp[i] <- logit(fixedp[i]) + gamma[cluster[i]] \n
p[i] <- 1/(1 + exp(-logitp[i])) \n
}\n
# priors \n
for(ic in 1:ncluster) {\n
gamma[ic] ~ dnorm(0, tau)\n
}\n
pC ~ dunif(0,1)\n
pI ~ dunif(0,1)\n
tau <- 1/(sigma*sigma) \n
sigma ~ dunif(0,3)\n
beta ~ dunif(initialTheta[1],initialTheta[2])\n
# derived quantities \n
Es <- 1 - pI/pC\n"
#    contamination diameter depends on model
text4 = switch(method,
'M1' = "theta <- (1 - alpha)*2*beta \n}\n",
'M2' = "theta <- 2 * qnorm(1 - 0.5*alpha,0,beta) \n}\n",
'M3' = "theta <- 2* log((1-0.5*alpha)/(0.5*alpha))/beta \n}\n")
MCMCmodel = paste0(text1,text2,text3,text4)
MCMCmodel
#    contamination diameter depends on model
text4 = switch(cfunc,
'S' = "theta <- (1 - alpha)*2*beta \n}\n",
'P' = "theta <- 2 * qnorm(1 - 0.5*alpha,0,beta) \n}\n",
'L' = "theta <- 2* log((1-0.5*alpha)/(0.5*alpha))/beta \n}\n")
MCMCmodel = paste0(text1,text2,text3,text4)
MCMCmodel
jagsout = jagsUI::autojags(data=datajags, inits=NULL,
parameters.to.save=c("Es","theta","pC","pI","beta"),
model.file=textConnection(MCMCmodel),
n.chains= nchains, n.adapt=NULL, iter.increment=200, n.burnin=burnin, n.thin=1)
burnin = 200
nchains = 4
jagsout = jagsUI::autojags(data=datajags, inits=NULL,
parameters.to.save=c("Es","theta","pC","pI","beta"),
model.file=textConnection(MCMCmodel),
n.chains= nchains, n.adapt=NULL, iter.increment=200, n.burnin=burnin, n.thin=1)
# mildly informative prior
initialTheta <- qnorm(1-alpha,sd = sqrt(2*sd^2))/(1-2*alpha)*c(1/4,4)
datajags<-with(trial,list(alpha=alpha,cluster=as.numeric(as.character(cluster)),
num=num,denom=denom,d=nearestDiscord,N=nrow(trial),
ncluster=max(as.numeric(as.character(cluster))),initialTheta=initialTheta))
# construct the rjags code by concatenating strings: text1 and text3 are model independent
#
#  "model{
#    for(i in 1:N){
#      num[i] ~ dbin(p[i],denom[i]) #every datapoint is drawn from a Binomial distribution with probability p
text1 = "model{\n for(i in 1:N){\n num[i] ~ dbin(p[i],denom[i]) \n"
text1 = "model{\n
for(i in 1:N){\n
num[i] ~ dbin(p[i],denom[i]) \n"
#      < text2: model excluding random effect is inserted here >
#   model for fixed effects
text2 = switch(cfunc,
'S' = "fixedp[i] <- ifelse(d[i] < -beta,pC,ifelse(d[i] > beta,pI,pI + (pC - pI) * (beta2 - d[i])/(2*beta)))\n",
'P' = "fixedp[i] <- pI + (pC-pI)*pnorm(-d[i],0,beta) \n",
'L' = "fixedp[i] <- pI + (pC-pI)/(1 + exp(beta*d[i])) \n")
text3 = "logitp[i] <- logit(fixedp[i]) + gamma[cluster[i]] \n
p[i] <- 1/(1 + exp(-logitp[i])) \n
}\n
# priors \n
for(ic in 1:ncluster) {\n
gamma[ic] ~ dnorm(0, tau)\n
}\n
pC ~ dunif(0,1)\n
pI ~ dunif(0,1)\n
tau <- 1/(sigma*sigma) \n
sigma ~ dunif(0,3)\n
beta ~ dunif(initialTheta[1],initialTheta[2])\n
# derived quantities \n
Es <- 1 - pI/pC\n"
#    contamination diameter depends on model
text4 = switch(cfunc,
'S' = "theta <- (1 - alpha)*2*beta \n}\n",
'P' = "theta <- 2 * qnorm(1 - 0.5*alpha,0,beta) \n}\n",
'L' = "theta <- 2* log((1-0.5*alpha)/(0.5*alpha))/beta \n}\n")
MCMCmodel = paste0(text1,text2,text3,text4)
jagsout = jagsUI::autojags(data=datajags, inits=NULL,
parameters.to.save=c("Es","theta","pC","pI","beta"),
model.file=textConnection(MCMCmodel),
n.chains= nchains, n.adapt=NULL, iter.increment=200, n.burnin=burnin, n.thin=1)
jagsout$q50$beta
alpha <- 0.5
cat("* Note: alpha set to 0.05 *\n" )
# mildly informative prior for beta
datajags<-with(trial,list(alpha=alpha,cluster=as.numeric(as.character(cluster)),
num=num,denom=denom,d=nearestDiscord,N=nrow(trial),
ncluster=max(as.numeric(as.character(cluster))),initialbeta=c(0.1,5)))
# construct the rjags code by concatenating strings: text1 and text3 are model independent
#
#  "model{
#    for(i in 1:N){
#      num[i] ~ dbin(p[i],denom[i]) #every datapoint is drawn from a Binomial distribution with probability p
text1 = "model{\n for(i in 1:N){\n num[i] ~ dbin(p[i],denom[i]) \n"
text1 = "model{\n
for(i in 1:N){\n
num[i] ~ dbin(p[i],denom[i]) \n"
#   model for fixed effects
text2 = switch(cfunc,
'S' = "lp[i] <- ifelse(d[i] < -beta,pC,ifelse(d[i] > beta,pI,pI + (pC - pI) * (beta2 - d[i])/(2*beta)))\n",
'P' = "lp[i] <- yI + (yC-yI)*pnorm(-d[i],0,beta) \n",
'L' = "lp[i] <- yI + (yC-yI)/(1 + exp(beta*d[i])) \n")
text3 = "logitp[i] <- logit(lp[i]) + gamma[cluster[i]] \n
y[i] <- 1/(1 + exp(-l[i])) \n
}\n
# priors \n
for(ic in 1:ncluster) {\n
gamma[ic] ~ dnorm(0, tau)\n
}\n
yC ~ dunif(0,1)\n
yI ~ dunif(0,1)\n
tau <- 1/(sigma*sigma) \n
sigma ~ dunif(0,3)\n
beta ~ dunif(initialbeta[1],initialbeta[2])\n
# derived quantities \n
Es <- 1 - yI/yC\n"
#    contamination diameter depends on contamination function
text4 = switch(cfunc,
'S' = "theta <- (1 - alpha)*2*beta \n}\n",
'P' = "theta <- 2 * qnorm(1 - 0.5*alpha,0,beta) \n}\n",
'L' = "theta <- 2* log((1-0.5*alpha)/(0.5*alpha))/beta \n}\n")
MCMCmodel = paste0(text1,text2,text3,text4)
nchains = 4
burnin = 200
jagsout = jagsUI::autojags(data=datajags, inits=NULL,
parameters.to.save=c("Es","theta","yC","yI","beta"),
model.file=textConnection(MCMCmodel),
n.chains= nchains, n.adapt=NULL, iter.increment=200, n.burnin=burnin, n.thin=1)
MCMCmodel
# construct the rjags code by concatenating strings: text1 and text3 are model independent
#every datapoint is drawn from a Binomial distribution with probability p
text1 = "model{\n for(i in 1:N){\n num[i] ~ dbin(p[i],denom[i]) \n"
text1 = "model{\n
for(i in 1:N){\n
num[i] ~ dbin(p[i],denom[i]) \n"
#   model for fixed effects
text2 = switch(cfunc,
'S' = "lp[i] <- ifelse(d[i] < -beta,pC,ifelse(d[i] > beta,pI,pI + (pC - pI) * (beta2 - d[i])/(2*beta)))\n",
'P' = "lp[i] <- yI + (yC-yI)*pnorm(-d[i],0,beta) \n",
'L' = "lp[i] <- yI + (yC-yI)/(1 + exp(beta*d[i])) \n")
text3 = "logitp[i] <- logit(lp[i]) + gamma[cluster[i]] \n
p[i] <- 1/(1 + exp(-l[i])) \n
}\n
# priors \n
for(ic in 1:ncluster) {\n
gamma[ic] ~ dnorm(0, tau)\n
}\n
yC ~ dunif(0,1)\n
yI ~ dunif(0,1)\n
tau <- 1/(sigma*sigma) \n
sigma ~ dunif(0,3)\n
beta ~ dunif(initialbeta[1],initialbeta[2])\n
# derived quantities \n
Es <- 1 - yI/yC\n"
#    contamination diameter depends on contamination function
text4 = switch(cfunc,
'S' = "theta <- (1 - alpha)*2*beta \n}\n",
'P' = "theta <- 2 * qnorm(1 - 0.5*alpha,0,beta) \n}\n",
'L' = "theta <- 2* log((1-0.5*alpha)/(0.5*alpha))/beta \n}\n")
MCMCmodel = paste0(text1,text2,text3,text4)
nchains = 4
burnin = 200
jagsout = jagsUI::autojags(data=datajags, inits=NULL,
parameters.to.save=c("Es","theta","yC","yI","beta"),
model.file=textConnection(MCMCmodel),
n.chains= nchains, n.adapt=NULL, iter.increment=200, n.burnin=burnin, n.thin=1)
formatR::tidy_source(arrow = TRUE)
formatR::tidy_source(arrow = TRUE)
text1
MCMCmodel
# construct the rjags code by concatenating strings: text1 and text3 are model independent
#every datapoint is drawn from a Binomial distribution with probability p
text1 <- "model{\n for(i in 1:N){\n num[i] ~ dbin(p[i],denom[i]) \n"
text1 <- "model{\n
for(i in 1:N){\n
num[i] ~ dbin(p[i],denom[i]) \n"
# model for fixed effects
text2 <- switch(cfunc, S = "lp[i] <- ifelse(d[i] < -beta,pC,ifelse(d[i] > beta,
pI,pI + (pC - pI) * (beta2 - d[i])/(2*beta)))\n",
P = "lp[i] <- yI + (yC-yI)*pnorm(-d[i],0,beta) \n",
L = "lp[i] <- yI + (yC-yI)/(1 + exp(beta*d[i])) \n")
text3 <- "logitp[i] <- logit(lp[i]) + gamma[cluster[i]] \n
p[i] <- 1/(1 + exp(-lp[i])) \n
}\n
# priors \n
for(ic in 1:ncluster) {\n
gamma[ic] ~ dnorm(0, tau)\n
}\n
yC ~ dunif(0, 1)\n
yI ~ dunif(0, 1)\n
tau <- 1/(sigma*sigma) \n
sigma ~ dunif(0, 3)\n
beta ~ dunif(0.1, 5)\n
# derived quantities \n
Es <- 1 - yI/yC\n"
# contamination diameter depends on contamination function
text4 <- switch(cfunc, S = "theta <- (1 - alpha)*2*beta \n}\n",
P = "theta <- 2 * qnorm(1 - 0.5*alpha,0,beta) \n}\n",
L = "theta <- 2* log((1-0.5*alpha)/(0.5*alpha))/beta \n}\n")
MCMCmodel <- paste0(text1, text2, text3, text4)
nchains <- 4
burnin <- 200
jagsout <- jagsUI::autojags(data = datajags, inits = NULL,
parameters.to.save = c("Es", "theta", "yC", "yI", "beta"),
model.file = textConnection(MCMCmodel), n.chains = nchains,
n.adapt = NULL, iter.increment = 200, n.burnin = burnin,
n.thin = 1)
results <- list(model.object = jagsout$sims.list, pt.ests = list(), int.ests = list(), method = method)
results$pt.ests$controlY <- jagsout$q50$yC
results$int.ests$controlY <- namedCL(c(jagsout$q2.5$yC, jagsout$q97.5$yC), alpha = alpha)
results$pt.ests$interventionY <- jagsout$q50$yI
results$int.ests$interventionY <- namedCL(c(jagsout$q2.5$yI, jagsout$q97.5$yI), alpha = alpha)
results$pt.ests$efficacy <- jagsout$q50$Es
results$int.ests$efficacy <- namedCL(c(jagsout$q2.5$Es, jagsout$q97.5$Es), alpha = alpha)
results$pt.ests$contaminationRange <- jagsout$q50$theta
results$int.ests$contaminationRange <- namedCL(c(jagsout$q2.5$theta, jagsout$q97.5$theta), alpha = alpha)
library(CRTspillover)
results6b <- Analyse_CRT(trial = example5a, method = 'MCMC')
results6b <- Analyse_CRT(trial = example5a, method = 'MCMC')
results6b <- Analyse_CRT(trial = example5a, method = 'MCMC')
FUN1
par0
par1
pt.ests$contamination.par
pt.ests
pt.ests$contamination.par = 0.5
par0 <- c(link_tr(link, limits0[1]),
link_tr(link, limits0[2]) - link_tr(link, limits0[1]),
pt.ests$contamination.par
)
par1 <- c(
link_tr(link, limits1[1]),
link_tr(link, limits1[2]) - link_tr(link, limits1[1]),
pt.ests$contamination.par
)
curve <- ifelse(d < 0,
invlink(link, FUN1(trial = data.frame(nearestDiscord = d), par = par0)),
invlink(link, FUN1(trial = data.frame(nearestDiscord = d), par = par1)))
# estimate contamination range The absolute values of the limits are used so that a positive range is
# obtained even with negative efficacy
thetaL <- thetaU <- NA
if (abs(limits0[1] - curve[1000]) >
0.025 * abs(limits0[1] - limits0[2]))
{
thetaL <- d[min(
which(
abs(limits0[1] - curve) >
0.025 * abs(limits0[1] - limits0[2])
)
)]
}
results6b$model.object$yC
results6b$method
Analyse_CRT(trial = example5a, method = 'GEE')
library(CRTspillover)
results6b <- Analyse_CRT(trial = example5a, method = 'MCMC')
library(CRTspillover)
results6b <- Analyse_CRT(trial = example5a, method = 'MCMC')
text3
text3 <- "logitp[i] <- logit(lp[i]) + gamma[cluster[i]] \n
p[i] <- 1/(1 + exp(-lp[i])) \n
cont[i] <- ifelse(abs(d[i]) < theta, 1, 0) \n
}\n
# priors \n
for(ic in 1:ncluster) {\n
gamma[ic] ~ dnorm(0, tau)\n
}\n
tau <- 1/(sigma * sigma) \n
sigma ~ dunif(0, 3) \n
beta ~ dunif(0.1, 5) \n
b0 ~ dnorm(0, 1E-3) \n
b1 ~ dnorm(0, 1E-3) \n
# derived quantities \n
yC <- 1/(1 + exp(-b0)) \n
yI <- 1/(1 + exp(-b1)) \n
Es <- 1 - yI/yC \n"
library(CRTspillover)
library(CRTspillover)
results6b <- Analyse_CRT(trial = example5a, method = 'MCMC')
library(CRTspillover)
results6b <- Analyse_CRT(trial = example5a, method = 'MCMC')
results6b <- Analyse_CRT(trial = example5a, method = 'MCMC')
# contamination diameter depends on contamination function
View(datajags)
text2 <- switch(cfunc, S = "lp[i] <- ifelse(d[i] < -beta,b0,ifelse(d[i] > beta,
b1, b1 + (b0 - b1) * (beta - d[i])/(2*beta)))\n",
P = "lp[i] <- b1 + (b0 - b1)*pnorm(-d[i], 0, beta) \n",
L = "lp[i] <- b1 + (b0 - b1)/(1 + exp(beta * d[i])) \n")
text3 <- "logitp[i] <- logit(lp[i] + gamma[cluster[i]]) \n
p[i] <- 1/(1 + exp(-logitp[i])) \n
cont[i] <- ifelse(abs(d[i]) < theta, 1, 0) \n
}\n
# priors \n
for(ic in 1:ncluster) {\n
gamma[ic] ~ dnorm(0, tau)\n
}\n
tau <- 1/(sigma * sigma) \n
sigma ~ dunif(0, 3) \n
beta ~ dunif(0.1, 5) \n
b0 ~ dnorm(0, 1E-3) \n
b1 ~ dnorm(0, 1E-3) \n
# derived quantities \n
yC <- 1/(1 + exp(-b0)) \n
yI <- 1/(1 + exp(-b1)) \n
Es <- 1 - yI/yC \n"
# contamination diameter depends on contamination function
text4 <- switch(cfunc, S = "theta <- (1 - alpha) * 2 * beta \n",
P = "theta <- 2 * qnorm(1 - 0.5*alpha,0,beta) \n",
L = "theta <- 2 * log((1-0.5*alpha)/(0.5*alpha))/beta \n")
text5 <- "pcont <- mean(cont)}\n"
MCMCmodel <- paste0(text1, text2, text3, text4,text5)
nchains <- 4
burnin <- 200
MCMCmodel
library(CRTspillover)
results6b <- Analyse_CRT(trial = example5a, method = 'MCMC')
