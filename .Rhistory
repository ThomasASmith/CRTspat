nn <- n - nt
if (nn > 1) {
# nn is the number of elements of alpha that have been assigned a value
# the missing elements should be removed
#call sort (alpha, nn)
alpha <- alpha[!is.na(alpha)]
alpha <- alpha[order(alpha)]
# check whether theta=(u,v) lies outside the data cloud
angle <- alpha[1] - alpha[nn] + 2 * pi
for (i in 2:nn) {
angle <- max(angle, (alpha[i] - alpha[i - 1]))
}
if (angle <= (pi + eps)) {
# make smallest alpha equal to zero, and compute nu = number of alpha < pi
angle <- alpha[1]
nu <- 0
for (i in 1:nn) {
alpha[i] <- alpha[i] - angle
if (alpha[i] < (pi - eps)) nu <- nu + 1
}
if (nu < nn) {
# merge sort the alpha with their antipodal angles beta, and at the same time
# update i,fval[i], and nbad
ja <- 1
jb <- 1
alphk <- alpha[1]
betak <- alpha[nu + 1] - pi
nn2 <- nn * 2
nbad <- 0
i <- nu
nf <- nn
for (j in 1:nn2) {
if ((alphk + eps) < betak) {
nf <- nf + 1
if (ja < nn) {
ja <- ja + 1
alphk <- alpha[ja]
} else {
alphk <- 2 * pi + 1
}
} else {
i <- i + 1
if (identical(i,(nn + 1))) {
i <- 1
nf <- nf - nn
}
fval[i] <- nf
nbad <- nbad + k((nf - i), 2)
if (jb < nn) {
jb <- jb + 1
if ((jb + nu) <= nn) {
betak <- alpha[jb + nu] - pi
} else {
betak <- alpha[jb + nu - nn] + pi
}
} else {
betak <- 2 * pi + 1.0
}
}
}
nums <- k(nn, 3) - nbad
# computation of numh for half space depth
gi <- 0
ja <- 1
angle <- alpha[1]
numh <- min(fval[1], (nn - fval[1]))
for (i in 2:nn) {
if (alpha[i] <= (angle + eps)) {
ja <- ja + 1
} else {
gi <- gi + ja
ja <- 1
angle <- alpha[i]
}
ki <- fval[i] - gi
numh <- min(numh, min(ki, (nn - ki)))
}
# adjust for the number nt of datapoints equal to theta
}
}
}
nums <- nums + k(nt, 1) * k(nn, 2) + k(nt, 2) * k(nn, 1) + k(nt, 3)
if (n >= 3) sdep <- nums/k(n, 3)
numh <- numh + nt
hdep <- numh/n
depths <- list(numh = numh, hdep = hdep, sdep = sdep)
}
junk <- apply(trial, MARGIN = 2, FUN = depths(), trial = trial)
? apply(array, margin, ...)
? dplyr::apply(array, margin, ...)
? dplyr::apply()
? apply()
depths <- function(X, trial) {
# this is an R translation of the fortran code in
# Rousseeuw & Ruts https://www.jstor.org/stable/2986073
# algorithm as 307.1 Appl.Statist. (1996), vol.45, no.4
# calculation of the simplicial depth and
# the half space depth
# u and v are the coordinates of the arbitrary point
u <- X[["x"]]
v <- X[["y"]]
# for the CRT application, consider only the arm within which the point is located
trial <- trial[trial$arm == X[[arm]],]
n <- nrow(trial)
x <- trial$x
y <- trial$y
nums <- 0
numh <- 0
sdep <- 0  # simplicial depth
hdep <- 0  # half-space depth
eps <- 1e-06
nt <- 0
# construct the vector alpha
alpha <- fval <- rep(NA, nrow(trial))
for (i in 1:n) {
d <- sqrt((x[i] - u) * (x[i] - u) + (y[i] - v) * (y[i] - v))
if (d <= eps) {
nt <- nt + 1
} else {
xu <- (x[i] - u)/d
yu <- (y[i] - v)/d
if (abs(xu) > abs(yu)) {
if (x[i] >= u) {
alpha[i - nt] <- asin(yu)
if (alpha[i - nt] < 0.0) {
alpha[i - nt] <- 2 * pi + alpha[i - nt]
}
} else {
alpha[i - nt] <- pi - asin(yu)
}
} else {
if (y[i] >= v) {
alpha[i - nt] <- acos(xu)
} else {
alpha[i - nt] <- 2 * pi - acos(xu)
}
}
if (alpha[i - nt] >= (2 * pi - eps)) alpha[i - nt] <- 0.0
}
}
nn <- n - nt
if (nn > 1) {
# nn is the number of elements of alpha that have been assigned a value
# the missing elements should be removed
#call sort (alpha, nn)
alpha <- alpha[!is.na(alpha)]
alpha <- alpha[order(alpha)]
# check whether theta=(u,v) lies outside the data cloud
angle <- alpha[1] - alpha[nn] + 2 * pi
for (i in 2:nn) {
angle <- max(angle, (alpha[i] - alpha[i - 1]))
}
if (angle <= (pi + eps)) {
# make smallest alpha equal to zero, and compute nu = number of alpha < pi
angle <- alpha[1]
nu <- 0
for (i in 1:nn) {
alpha[i] <- alpha[i] - angle
if (alpha[i] < (pi - eps)) nu <- nu + 1
}
if (nu < nn) {
# merge sort the alpha with their antipodal angles beta, and at the same time
# update i,fval[i], and nbad
ja <- 1
jb <- 1
alphk <- alpha[1]
betak <- alpha[nu + 1] - pi
nn2 <- nn * 2
nbad <- 0
i <- nu
nf <- nn
for (j in 1:nn2) {
if ((alphk + eps) < betak) {
nf <- nf + 1
if (ja < nn) {
ja <- ja + 1
alphk <- alpha[ja]
} else {
alphk <- 2 * pi + 1
}
} else {
i <- i + 1
if (identical(i,(nn + 1))) {
i <- 1
nf <- nf - nn
}
fval[i] <- nf
nbad <- nbad + k((nf - i), 2)
if (jb < nn) {
jb <- jb + 1
if ((jb + nu) <= nn) {
betak <- alpha[jb + nu] - pi
} else {
betak <- alpha[jb + nu - nn] + pi
}
} else {
betak <- 2 * pi + 1.0
}
}
}
nums <- k(nn, 3) - nbad
# computation of numh for half space depth
gi <- 0
ja <- 1
angle <- alpha[1]
numh <- min(fval[1], (nn - fval[1]))
for (i in 2:nn) {
if (alpha[i] <= (angle + eps)) {
ja <- ja + 1
} else {
gi <- gi + ja
ja <- 1
angle <- alpha[i]
}
ki <- fval[i] - gi
numh <- min(numh, min(ki, (nn - ki)))
}
# adjust for the number nt of datapoints equal to theta
}
}
}
nums <- nums + k(nt, 1) * k(nn, 2) + k(nt, 2) * k(nn, 1) + k(nt, 3)
if (n >= 3) sdep <- nums/k(n, 3)
numh <- numh + nt
hdep <- numh/n
depths <- list(numh = numh, hdep = hdep, sdep = sdep)
}
junk <- apply(trial, MARGIN = 2, FUN = depths(), trial = trial)
junk <- apply(trial, MARGIN = 2, FUN = depths, trial = trial)
junk <- apply(trial, MARGIN = 1, FUN = depths, trial = trial)
junk <- apply(trial, MARGIN = 2, FUN = depths, trial = trial)
junk <- apply(trial, MARGIN = 1, FUN = depths, trial = trial)
depths <- function(X, trial) {
# this is an R translation of the fortran code in
# Rousseeuw & Ruts https://www.jstor.org/stable/2986073
# algorithm as 307.1 Appl.Statist. (1996), vol.45, no.4
# calculation of the simplicial depth and
# the half space depth
# u and v are the coordinates of the arbitrary point
u <- X[["x"]]
v <- X[["y"]]
# for the CRT application, consider only the arm within which the point is located
trial <- trial[trial$arm == X[["arm"]],]
n <- nrow(trial)
x <- trial$x
y <- trial$y
nums <- 0
numh <- 0
sdep <- 0  # simplicial depth
hdep <- 0  # half-space depth
eps <- 1e-06
nt <- 0
# construct the vector alpha
alpha <- fval <- rep(NA, nrow(trial))
for (i in 1:n) {
d <- sqrt((x[i] - u) * (x[i] - u) + (y[i] - v) * (y[i] - v))
if (d <= eps) {
nt <- nt + 1
} else {
xu <- (x[i] - u)/d
yu <- (y[i] - v)/d
if (abs(xu) > abs(yu)) {
if (x[i] >= u) {
alpha[i - nt] <- asin(yu)
if (alpha[i - nt] < 0.0) {
alpha[i - nt] <- 2 * pi + alpha[i - nt]
}
} else {
alpha[i - nt] <- pi - asin(yu)
}
} else {
if (y[i] >= v) {
alpha[i - nt] <- acos(xu)
} else {
alpha[i - nt] <- 2 * pi - acos(xu)
}
}
if (alpha[i - nt] >= (2 * pi - eps)) alpha[i - nt] <- 0.0
}
}
nn <- n - nt
if (nn > 1) {
# nn is the number of elements of alpha that have been assigned a value
# the missing elements should be removed
#call sort (alpha, nn)
alpha <- alpha[!is.na(alpha)]
alpha <- alpha[order(alpha)]
# check whether theta=(u,v) lies outside the data cloud
angle <- alpha[1] - alpha[nn] + 2 * pi
for (i in 2:nn) {
angle <- max(angle, (alpha[i] - alpha[i - 1]))
}
if (angle <= (pi + eps)) {
# make smallest alpha equal to zero, and compute nu = number of alpha < pi
angle <- alpha[1]
nu <- 0
for (i in 1:nn) {
alpha[i] <- alpha[i] - angle
if (alpha[i] < (pi - eps)) nu <- nu + 1
}
if (nu < nn) {
# merge sort the alpha with their antipodal angles beta, and at the same time
# update i,fval[i], and nbad
ja <- 1
jb <- 1
alphk <- alpha[1]
betak <- alpha[nu + 1] - pi
nn2 <- nn * 2
nbad <- 0
i <- nu
nf <- nn
for (j in 1:nn2) {
if ((alphk + eps) < betak) {
nf <- nf + 1
if (ja < nn) {
ja <- ja + 1
alphk <- alpha[ja]
} else {
alphk <- 2 * pi + 1
}
} else {
i <- i + 1
if (identical(i,(nn + 1))) {
i <- 1
nf <- nf - nn
}
fval[i] <- nf
nbad <- nbad + k((nf - i), 2)
if (jb < nn) {
jb <- jb + 1
if ((jb + nu) <= nn) {
betak <- alpha[jb + nu] - pi
} else {
betak <- alpha[jb + nu - nn] + pi
}
} else {
betak <- 2 * pi + 1.0
}
}
}
nums <- k(nn, 3) - nbad
# computation of numh for half space depth
gi <- 0
ja <- 1
angle <- alpha[1]
numh <- min(fval[1], (nn - fval[1]))
for (i in 2:nn) {
if (alpha[i] <= (angle + eps)) {
ja <- ja + 1
} else {
gi <- gi + ja
ja <- 1
angle <- alpha[i]
}
ki <- fval[i] - gi
numh <- min(numh, min(ki, (nn - ki)))
}
# adjust for the number nt of datapoints equal to theta
}
}
}
nums <- nums + k(nt, 1) * k(nn, 2) + k(nt, 2) * k(nn, 1) + k(nt, 3)
if (n >= 3) sdep <- nums/k(n, 3)
numh <- numh + nt
hdep <- numh/n
depths <- list(numh = numh, hdep = hdep, sdep = sdep)
}
junk <- apply(trial, MARGIN = 1, FUN = depths, trial = trial)
depths <- function(X, trial) {
# this is an R translation of the fortran code in
# Rousseeuw & Ruts https://www.jstor.org/stable/2986073
# algorithm as 307.1 Appl.Statist. (1996), vol.45, no.4
# calculation of the simplicial depth and
# the half space depth
# u and v are the coordinates of the arbitrary point
u <- as.numeric(X[["x"]])
v <- as.numeric(X[["y"]])
# for the CRT application, consider only the arm within which the point is located
trial <- trial[trial$arm == X[["arm"]],]
n <- nrow(trial)
x <- trial$x
y <- trial$y
nums <- 0
numh <- 0
sdep <- 0  # simplicial depth
hdep <- 0  # half-space depth
eps <- 1e-06
nt <- 0
# construct the vector alpha
alpha <- fval <- rep(NA, nrow(trial))
for (i in 1:n) {
d <- sqrt((x[i] - u) * (x[i] - u) + (y[i] - v) * (y[i] - v))
if (d <= eps) {
nt <- nt + 1
} else {
xu <- (x[i] - u)/d
yu <- (y[i] - v)/d
if (abs(xu) > abs(yu)) {
if (x[i] >= u) {
alpha[i - nt] <- asin(yu)
if (alpha[i - nt] < 0.0) {
alpha[i - nt] <- 2 * pi + alpha[i - nt]
}
} else {
alpha[i - nt] <- pi - asin(yu)
}
} else {
if (y[i] >= v) {
alpha[i - nt] <- acos(xu)
} else {
alpha[i - nt] <- 2 * pi - acos(xu)
}
}
if (alpha[i - nt] >= (2 * pi - eps)) alpha[i - nt] <- 0.0
}
}
nn <- n - nt
if (nn > 1) {
# nn is the number of elements of alpha that have been assigned a value
# the missing elements should be removed
#call sort (alpha, nn)
alpha <- alpha[!is.na(alpha)]
alpha <- alpha[order(alpha)]
# check whether theta=(u,v) lies outside the data cloud
angle <- alpha[1] - alpha[nn] + 2 * pi
for (i in 2:nn) {
angle <- max(angle, (alpha[i] - alpha[i - 1]))
}
if (angle <= (pi + eps)) {
# make smallest alpha equal to zero, and compute nu = number of alpha < pi
angle <- alpha[1]
nu <- 0
for (i in 1:nn) {
alpha[i] <- alpha[i] - angle
if (alpha[i] < (pi - eps)) nu <- nu + 1
}
if (nu < nn) {
# merge sort the alpha with their antipodal angles beta, and at the same time
# update i,fval[i], and nbad
ja <- 1
jb <- 1
alphk <- alpha[1]
betak <- alpha[nu + 1] - pi
nn2 <- nn * 2
nbad <- 0
i <- nu
nf <- nn
for (j in 1:nn2) {
if ((alphk + eps) < betak) {
nf <- nf + 1
if (ja < nn) {
ja <- ja + 1
alphk <- alpha[ja]
} else {
alphk <- 2 * pi + 1
}
} else {
i <- i + 1
if (identical(i,(nn + 1))) {
i <- 1
nf <- nf - nn
}
fval[i] <- nf
nbad <- nbad + k((nf - i), 2)
if (jb < nn) {
jb <- jb + 1
if ((jb + nu) <= nn) {
betak <- alpha[jb + nu] - pi
} else {
betak <- alpha[jb + nu - nn] + pi
}
} else {
betak <- 2 * pi + 1.0
}
}
}
nums <- k(nn, 3) - nbad
# computation of numh for half space depth
gi <- 0
ja <- 1
angle <- alpha[1]
numh <- min(fval[1], (nn - fval[1]))
for (i in 2:nn) {
if (alpha[i] <= (angle + eps)) {
ja <- ja + 1
} else {
gi <- gi + ja
ja <- 1
angle <- alpha[i]
}
ki <- fval[i] - gi
numh <- min(numh, min(ki, (nn - ki)))
}
# adjust for the number nt of datapoints equal to theta
}
}
}
nums <- nums + k(nt, 1) * k(nn, 2) + k(nt, 2) * k(nn, 1) + k(nt, 3)
if (n >= 3) sdep <- nums/k(n, 3)
numh <- numh + nt
hdep <- numh/n
depths <- list(numh = numh, hdep = hdep, sdep = sdep)
}
junk <- apply(trial, MARGIN = 1, FUN = depths, trial = trial)
View(junk)
jun1 <- data.frame(junk)
View(jun1)
junk <- lapply(trial, MARGIN = 1, FUN = depths, trial = trial)
junk <- lapply(trial, FUN = depths, trial = trial)
junk <- sapply(trial, FUN = depths, trial = trial)
junk_df <- as.data.frame(do.call(rbind, lapply(junk, as.data.frame)))
View(junk_df)
