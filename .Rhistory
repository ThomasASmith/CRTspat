returnlist <- list(power = power, clustersRequired = clustersRequired, DE = DE, delta = delta)
return(returnlist)
}
power(yC = 0.0148, yI = 0.0104, denom_per_cluster = 424, k = 0.29, Zsig = 1.96, Zpow = NULL, c = 28,
sigma_r = 0, sigma_m = 0, sigma_x = NULL, nearestDiscord = NULL)
# from Smith et al equation (23)
delta_t <- (delta * yC)/(yC + yI + delta)
delta = 0
# from Smith et al equation (23)
delta_t <- (delta * yC)/(yC + yI + delta)
delta <- 0.2
# from Smith et al equation (23)
delta_t <- (delta * yC)/(yC + yI + delta)
yC
yI
E <- 1- yC/yI
E
E <- 1- yI/yC
E
# from Smith et al equation (23)
delta_t <- (delta * yC)/(yC + yI + delta)
delta <- -0.2
# from Smith et al equation (23)
delta_t <- (delta * yC)/(yC + yI + delta)
# from Smith et al equation (23)
delta_t
E <- 1- (yI - delta_t)/(yC + delta_t)
E
E <- 1- yI/yC + delta
delta_t <- -(delta * yC)/(yC + yI + delta)
E <- 1- (yI - delta_t)/(yC + delta_t)
E
E <- 1- yI/yC + delta
E
delta
# from Smith et al equation (23)
delta_t <- (delta * yC)/(yC + yI + delta)
# from Smith et al equation (23)
delta_t
yC
yI
# from Smith et al equation (23)
delta_t <- (-delta * yC^2)/(yC + yI + delta*yC)
delta_t
E
E <- 1- yI/yC + delta
E
E2 <- 1 - (yI - delta_t)/(yC + delta_t)
E2
E <- 1- yI/yC
E1 <- 1- yI/yC + delta
E1
E
delta
E2 <- 1 - (yI - delta_t)/(yC + delta_t)
E2
E2 <- 1 - (yI + delta_t)/(yC - delta_t)
E2
delta_t <- (delta * yC^2)/(yC + yI - delta*yC)
E2 <- 1 - (yI - delta_t)/(yC + delta_t)
E2
E1 <- 1- yI/yC + delta
E1
power <- function(yC, yI, denom_per_cluster, k, Zsig, Zpow = NULL, c = NULL,
sigma_r = 0, sigma_m = 0, sigma_x = NULL, nearestDiscord = NULL){
# for calculating the spillover either sigma_r or both sigma_m and sigma_x must be available
# sigma_m = 0 is the default corresponding to no spillover
# if nearestDiscord is provided then the standard deviation of nearestDiscord is used for sigma_x
if(!is.null(nearestDiscord)) sigma_x <- sd(nearestDiscord)
if(!is.null(sigma_x)) sigma_r <- sigma_m/sigma_x
# calculate true efficacy
E <- 1 - yI/yC
# Compute bias only if sigma_r > 0
if (sigma_r > 0) {
# calculate delta
list(E = E, sigma_r = sigma_r)
deltalist <- get_delta(X, nearestDiscord = nearestDiscord)
delta <- deltalist$delta
} else {
delta <- 0
}
# from Smith et al equation (23)
delta_t <- (delta * yC^2)/(yC + yI - delta*yC)
# use the formulae from Hayes & Bennett (1999) https://doi.org/10.1093/ije/28.2.319 as modified for spillover
# clusters required (both arms)
den <- denom_per_cluster
if (is.null(Zpow)) {
if (!is.null(c)) {
# power with c clusters per arm and equal cluster sizes
Zpow <- sqrt((c - 1) * ((yC - yI + delta_t)^2)/((yC + yI)/den +
(k^2) * ((yC + delta_t/2)^2 + (yI - delta_t/2)^2))) - Zsig
cat(Zpow, c, k, delta, delta_t, den, '\n')
}
}
clustersRequired <- 2 * ceiling(1 + (Zsig + Zpow)^2 * ((yC - yI + delta_t)^2)/((yC + yI)/den
+ (k^2) * ((yC + delta_t/2)^2 + (yI - delta_t/2)^2))/((yC - yI + delta_t)^2))
power <- stats::pnorm(Zpow)
# the design effect is the ratio of the required denominator to that required for an individually randomised trial
required_denom_RCT <- 2 * ((Zsig + Zpow)^2 * (yC + yI)/((yC - yI)^2))
DE <- den * clustersRequired/required_denom_RCT
returnlist <- list(power = power, clustersRequired = clustersRequired, DE = DE, delta = delta)
return(returnlist)
}
power(yC = 0.0148, yI = 0.0104, denom_per_cluster = 424, k = 0.29, Zsig = 1.96, Zpow = NULL, c = 28,
sigma_r = 0, sigma_m = 0, sigma_x = NULL, nearestDiscord = NULL)
power <- function(yC, yI, denom_per_cluster, k, Zsig, Zpow = NULL, c = NULL,
sigma_r = 0, sigma_m = 0, sigma_x = NULL, nearestDiscord = NULL){
# for calculating the spillover either sigma_r or both sigma_m and sigma_x must be available
# sigma_m = 0 is the default corresponding to no spillover
# if nearestDiscord is provided then the standard deviation of nearestDiscord is used for sigma_x
if(!is.null(nearestDiscord)) sigma_x <- sd(nearestDiscord)
if(!is.null(sigma_x)) sigma_r <- sigma_m/sigma_x
# calculate true efficacy
E <- 1 - yI/yC
# Compute bias only if sigma_r > 0
if (sigma_r > 0) {
# calculate delta
list(E = E, sigma_r = sigma_r)
deltalist <- get_delta(X, nearestDiscord = nearestDiscord)
delta <- deltalist$delta
} else {
delta <- 0
}
# from Smith et al equation (23)
delta_t <- (delta * yC^2)/(yC + yI - delta*yC)
# use the formulae from Hayes & Bennett (1999) https://doi.org/10.1093/ije/28.2.319 as modified for spillover
# clusters required (both arms)
den <- denom_per_cluster
if (is.null(Zpow)) {
if (!is.null(c)) {
# power with c clusters per arm and equal cluster sizes
Zpow <- sqrt((c - 1) * ((yC - yI + delta_t)^2)/((yC + yI)/den +
(k^2) * ((yC + delta_t/2)^2 + (yI - delta_t/2)^2))) - Zsig
cat(Zpow, c, k, delta, delta_t, den, '\n')
}
}
clustersRequired <- 2 * ceiling(1 + (Zsig + Zpow)^2 * ((yC + yI)/den +
(k^2) * ((yC + delta_t/2)^2 + (yI - delta_t/2)^2))/((yC - yI + delta_t)^2))
power <- stats::pnorm(Zpow)
# the design effect is the ratio of the required denominator to that required for an individually randomised trial
required_denom_RCT <- 2 * ((Zsig + Zpow)^2 * (yC + yI)/((yC - yI)^2))
DE <- den * clustersRequired/required_denom_RCT
returnlist <- list(power = power, clustersRequired = clustersRequired, DE = DE, delta = delta)
return(returnlist)
}
power(yC = 0.0148, yI = 0.0104, denom_per_cluster = 424, k = 0.29, Zsig = 1.96, Zpow = NULL, c = 28,
sigma_r = 0, sigma_m = 0, sigma_x = NULL, nearestDiscord = NULL)
power(yC = 0.0148, yI = 0.0104, denom_per_cluster = 424, k = 0.29, Zsig = 1.96, Zpow = NULL, c = 28,
sigma_r = 1, sigma_m = 0, sigma_x = NULL, nearestDiscord = NULL)
power(yC = 0.0148, yI = 0.0104, denom_per_cluster = 424, k = 0.29, Zsig = 1.96, Zpow = NULL, c = 28,
sigma_r = 1, sigma_m = 0, sigma_x = NULL, nearestDiscord = NULL)
power <- function(yC, yI, denom_per_cluster, k, Zsig, Zpow = NULL, c = NULL,
sigma_r = 0, sigma_m = 0, sigma_x = NULL, nearestDiscord = NULL){
# for calculating the spillover either sigma_r or both sigma_m and sigma_x must be available
# sigma_m = 0 is the default corresponding to no spillover
# if nearestDiscord is provided then the standard deviation of nearestDiscord is used for sigma_x
if(!is.null(nearestDiscord)) sigma_x <- sd(nearestDiscord)
if(!is.null(sigma_x)) sigma_r <- sigma_m/sigma_x
# calculate true efficacy
E <- 1 - yI/yC
# Compute bias only if sigma_r > 0
if (sigma_r > 0) {
# calculate delta
deltalist <- get_delta(X = list(E = E, sigma_r = sigma_r), nearestDiscord = nearestDiscord)
delta <- deltalist$delta
} else {
delta <- 0
}
# from Smith et al equation (23)
delta_t <- (delta * yC^2)/(yC + yI - delta*yC)
# use the formulae from Hayes & Bennett (1999) https://doi.org/10.1093/ije/28.2.319 as modified for spillover
# clusters required (both arms)
den <- denom_per_cluster
if (is.null(Zpow)) {
if (!is.null(c)) {
# power with c clusters per arm and equal cluster sizes
Zpow <- sqrt((c - 1) * ((yC - yI + delta_t)^2)/((yC + yI)/den +
(k^2) * ((yC + delta_t/2)^2 + (yI - delta_t/2)^2))) - Zsig
cat(Zpow, c, k, delta, delta_t, den, '\n')
}
}
clustersRequired <- 2 * ceiling(1 + (Zsig + Zpow)^2 * ((yC + yI)/den +
(k^2) * ((yC + delta_t/2)^2 + (yI - delta_t/2)^2))/((yC - yI + delta_t)^2))
power <- stats::pnorm(Zpow)
# the design effect is the ratio of the required denominator to that required for an individually randomised trial
required_denom_RCT <- 2 * ((Zsig + Zpow)^2 * (yC + yI)/((yC - yI)^2))
DE <- den * clustersRequired/required_denom_RCT
returnlist <- list(power = power, clustersRequired = clustersRequired, DE = DE, delta = delta)
return(returnlist)
}
power(yC = 0.0148, yI = 0.0104, denom_per_cluster = 424, k = 0.29, Zsig = 1.96, Zpow = NULL, c = 28,
sigma_r = 1, sigma_m = 0, sigma_x = NULL, nearestDiscord = NULL)
power(yC = 0.0148, yI = 0.0104, denom_per_cluster = 424, k = 0.29, Zsig = 1.96, Zpow = NULL, c = 28,
sigma_r = 0, sigma_m = 0, sigma_x = NULL, nearestDiscord = NULL)
power(yC = 0.0148, yI = 0.0104, denom_per_cluster = 424, k = 0.29, Zsig = 1.96, Zpow = NULL, c = 28,
sigma_r = 0, sigma_m = 1, sigma_x = 2, nearestDiscord = NULL)
power <- function(yC, yI, denom_per_cluster, k, Zsig, Zpow = NULL, c = NULL,
sigma_r = 0, sigma_m = 0, sigma_x = NULL, nearestDiscord = NULL){
# for calculating the spillover either sigma_r or both sigma_m and sigma_x must be available
# sigma_m = 0 is the default corresponding to no spillover
# if nearestDiscord is provided then the standard deviation of nearestDiscord is used for sigma_x
if(!is.null(nearestDiscord)) sigma_x <- sd(nearestDiscord)
if(!is.null(sigma_x)) sigma_r <- sigma_m/sigma_x
# calculate true efficacy
E <- 1 - yI/yC
# Compute bias only if sigma_r > 0
if (sigma_r > 0) {
# calculate delta
deltalist <- get_delta(X = list(E = E, sigma_r = sigma_r), nearestDiscord = nearestDiscord)
delta <- deltalist$delta
} else {
delta <- 0
}
# from Smith et al equation (23)
delta_t <- (delta * yC^2)/(yC + yI - delta*yC)
# use the formulae from Hayes & Bennett (1999) https://doi.org/10.1093/ije/28.2.319 as modified for spillover
# clusters required (both arms)
den <- denom_per_cluster
if (is.null(Zpow)) {
if (!is.null(c)) {
# power with c clusters per arm and equal cluster sizes
Zpow <- sqrt((c - 1) * ((yC - yI + delta_t)^2)/((yC + yI)/den +
(k^2) * ((yC + delta_t/2)^2 + (yI - delta_t/2)^2))) - Zsig
}
}
clustersRequired <- 2 * ceiling(1 + (Zsig + Zpow)^2 * ((yC + yI)/den +
(k^2) * ((yC + delta_t/2)^2 + (yI - delta_t/2)^2))/((yC - yI + delta_t)^2))
power <- stats::pnorm(Zpow)
# the design effect is the ratio of the total denominator to that required for an individually randomized trial
# with no spillover
required_denom_RCT <- 2 * ((Zsig + Zpow)^2 * (yC + yI)/((yC - yI)^2))
DE <- den * clustersRequired/required_denom_RCT
returnlist <- list(power = power, clustersRequired = clustersRequired, DE = DE, delta = delta)
return(returnlist)
}
power(yC = 0.0148, yI = 0.0104, denom_per_cluster = 424, k = 0.29, Zsig = 1.96, Zpow = NULL, c = 28,
sigma_r = 0, sigma_m = 1, sigma_x = 2, nearestDiscord = NULL)
power(yC = 0.0148, yI = 0.0104, denom_per_cluster = 424, k = 0.29, Zsig = 1.96, Zpow = NULL, c = 28,
sigma_r = 0, sigma_m = 2, sigma_x = 1, nearestDiscord = NULL)
power(yC = 0.0148, yI = 0.0104, denom_per_cluster = 424, k = 0.29, Zsig = 1.96, Zpow = 0.8, c = 28,
sigma_r = 0, sigma_m = 2, sigma_x = 1, nearestDiscord = NULL)
power(yC = 0.0148, yI = 0.0104, denom_per_cluster = 424, k = 0.29, Zsig = 1.96, Zpow = 0.8, c = 28,
sigma_r = 0, sigma_m = 1, sigma_x = 2, nearestDiscord = NULL)
power <- function(yC, yI, denom_per_cluster, k, Zsig, Zpow = NULL, c = NULL,
sigma_r = 0, sigma_m = 0, sigma_x = NULL, nearestDiscord = NULL){
# for calculating the spillover either sigma_r or both sigma_m and sigma_x must be available
# sigma_m = 0 is the default corresponding to no spillover
# if nearestDiscord is provided then the standard deviation of nearestDiscord is used for sigma_x
if(!is.null(nearestDiscord)) sigma_x <- sd(nearestDiscord)
if(!is.null(sigma_x)) sigma_r <- sigma_m/sigma_x
# calculate true efficacy
E <- 1 - yI/yC
# Compute bias only if sigma_r > 0
if (sigma_r > 0) {
# calculate delta
deltalist <- get_delta(X = list(E = E, sigma_r = sigma_r), nearestDiscord = nearestDiscord)
delta <- deltalist$delta
} else {
delta <- 0
}
# from Smith et al equation (23)
delta_t <- (delta * yC^2)/(yC + yI - delta*yC)
# use the formulae from Hayes & Bennett (1999) https://doi.org/10.1093/ije/28.2.319 as modified for spillover
# clusters required (both arms)
den <- denom_per_cluster
if (is.null(Zpow)) {
if (!is.null(c)) {
# power with c clusters per arm and equal cluster sizes
Zpow <- sqrt((c - 1) * ((yC - yI + delta_t)^2)/((yC + yI)/den +
(k^2) * ((yC + delta_t/2)^2 + (yI - delta_t/2)^2))) - Zsig
clustersRequired <- 2 * c
} else {
Zpow <- NA
clustersRequired <- NA
}
} else {
clustersRequired <- 2 * ceiling(1 + (Zsig + Zpow)^2 * ((yC + yI)/den +
(k^2) * ((yC + delta_t/2)^2 + (yI - delta_t/2)^2))/((yC - yI + delta_t)^2))
}
power <- stats::pnorm(Zpow)
# the design effect is the ratio of the total denominator to that required for an individually randomized trial
# with no spillover
required_denom_RCT <- 2 * ((Zsig + Zpow)^2 * (yC + yI)/((yC - yI)^2))
DE <- den * clustersRequired/required_denom_RCT
returnlist <- list(power = power, clustersRequired = clustersRequired, DE = DE, delta = delta)
return(returnlist)
}
exampleCRT
? CRTspat
examplePower3 = CRTpower(trial = readdata('example_site.csv'), desiredPower = 0.8,
effect=0.4, yC=0.35, outcome_type = 'd', ICC = 0.05, c = 20)
library(CRTspat)
examplePower3 = CRTpower(trial = readdata('example_site.csv'), desiredPower = 0.8,
effect=0.4, yC=0.35, outcome_type = 'd', ICC = 0.05, c = 20)
trial = readdata('example_site.csv')
View(trial)
trial = readdata('exampleCRT.txt')
power(yC = 0.0148, yI = 0.0104, denom_per_cluster = 424, k = 0.29, Zsig = 1.96, Zpow = 0.8, c = 28,
sigma_r = 0, sigma_m = 1, sigma_x = 2, nearestDiscord = CRT$trial$nearestDiscord)
CRT = readdata('exampleCRT.txt')
power(yC = 0.0148, yI = 0.0104, denom_per_cluster = 424, k = 0.29, Zsig = 1.96, Zpow = 0.8, c = 28,
sigma_r = 0, sigma_m = 1, sigma_x = 2, nearestDiscord = CRT$trial$nearestDiscord)
? CRTpower
summary(examplePower3
)
(pnorm(sigma_r) - pnorm(-sigma_r))
(pnorm(1) - pnorm(-1))
qnorm(0.025)
? qnorm
? qnorm(1)
qnorm(1)
qnorm(0.975)
pnorm(1)
pnorm(1)/qnorm(0.975)
? analyseCRT
? CRTanalysis
exampleLME4 <- CRTanalysis(example, method = "LME4", cfunc = "P")
summary(exampleLME4)
version()
Rversion()
? version()
R.Version()
power <- function(yC, yI, denom_per_cluster, k, Zsig, Zpow = NULL, c = NULL,
sigma_r = 0, spillover_interval = 0, contaminate_pop_pr = NULL,
nearestDiscord = NULL, distance_distribution = 'normal'){
# The calculations can be adjusted for effects of spillover based on a diffusion model of mosquito movement. If no locations
# are provided an error function model of spillover is parameterized using either 'sigma_r' or 'contaminate_pop_pr'.
# The default is 'sigma_r = 0' corresponding to no spillover.
# If a set of randomized locations is provided in a trial data frame and 'contaminate_pop_pr > 0' or 'spillover_interval > 0' then the spillover is modeled based on the distribution of 'nearestDiscord'.
# if a normal approximation for the distances is required (distance_distribution = 'normal') then an analytical model parameterized using the
# standard deviation of 'nearestDiscord' is used to calculate the spillover bias 'delta'. If distance_distribution = 'empirical' then the empirical distribution of 'nearestDiscord' is used,
# and 'delta' is calculated by Monte Carlo integration.
if(!is.null(spillover_interval)) sigma_m <- spillover_interval/(2 * qnorm(0.975))
if(!is.null(nearestDiscord) & !identical(distance_distribution, 'empirical')) sigma_x <- sd(nearestDiscord)
if(!is.null(sigma_x) & !is.null(sigma_m)) sigma_r <- sigma_m/sigma_x
# If 'contaminate_pop_pr' is provided sigma_m based on the spillover interval is ignored
if(!is.null(contaminate_pop_pr)) sigma_r <- qnorm(0.025)/qnorm((1-contaminate_pop_pr)/2)
# calculate true efficacy
E <- 1 - yI/yC
# Compute bias only if sigma_r > 0
if (sigma_r > 0) {
# calculate delta
delta <- get_delta(X = list(E = E, sigma_r = sigma_r),
distance_distribution = distance_distribution,
nearestDiscord = nearestDiscord)
} else {
delta <- 0
}
# from Smith et al equation (23)
delta_t <- (delta * yC^2)/(yC + yI - delta*yC)
# use the formulae from Hayes & Bennett (1999) https://doi.org/10.1093/ije/28.2.319 as modified for spillover
den <- denom_per_cluster
if (is.null(Zpow)) {
if (!is.null(c)) {
# power with c clusters per arm and equal cluster sizes
Zpow <- sqrt((c - 1) * ((yC - yI + delta_t)^2)/((yC + yI)/den +
(k^2) * ((yC + delta_t/2)^2 + (yI - delta_t/2)^2))) - Zsig
clustersRequired <- 2 * c
} else {
Zpow <- NA
clustersRequired <- NA
}
} else {
# clusters required (both arms)
clustersRequired <- 2 * ceiling(1 + (Zsig + Zpow)^2 * ((yC + yI)/den +
(k^2) * ((yC + delta_t/2)^2 + (yI - delta_t/2)^2))/((yC - yI + delta_t)^2))
}
power <- stats::pnorm(Zpow)
# the design effect is the ratio of the total denominator to that required for an individually randomized trial
# with no spillover
required_denom_RCT <- 2 * ((Zsig + Zpow)^2 * (yC + yI)/((yC - yI)^2))
DE <- den * clustersRequired/required_denom_RCT
returnlist <- list(power = power, clustersRequired = clustersRequired, DE = DE, delta = delta)
return(returnlist)
}
# delta calculation assuming p is normally distributed
get_delta  <- function(X, distance_distribution = 'normal', nearestDiscord = NULL) {
sigma_r <- X[["sigma_r"]]
E <- X[["E"]]
if(identical(distance_distribution, 'empirical') & !is.null(nearestDiscord)) {
# delta calculation using empirical distribution of distance
u0 <- 1
u <- u0 * (1 - E * pnorm(nearestDiscord/sigma_r))
E_tilde <- 1 - mean(u[nearestDiscord > 0])/mean(u[nearestDiscord < 0])
} else {
# analytical solution
integral1 <-  (1/(2*pi)) * (pi/2 + atan(1/sigma_r))
integral2 <-  (1/(2*pi)) * (pi/2 - atan(1/sigma_r))
E_tilde <- 1 - (0.5 - E * integral1)/(0.5 - E * integral2)
}
delta <- E_tilde - E
return(delta)}
power(yC = 0.0148, yI = 0.0104, denom_per_cluster = 424, k = 0.29, Zsig = 1.96, Zpow = 0.8, c = 28,
=
sigma_r = 0, sigma_m = 1, sigma_x = 2, nearestDiscord = CRT$trial$nearestDiscord)
power(yC = 0.0148, yI = 0.0104, denom_per_cluster = 424, k = 0.29, Zsig = 1.96, Zpow = 0.8, c = 28,
sigma_r = 0, sigma_m = 1, sigma_x = 2, nearestDiscord = CRT$trial$nearestDiscord)
power(yC = 0.0148, yI = 0.0104, denom_per_cluster = 424, k = 0.29, Zsig = 1.96, Zpow = 0.8, c = 28,
sigma_r = 0, contaminate_pop_pr = 0, nearestDiscord = CRT$trial$nearestDiscord, distance_distribution = 'normal')
library(CRTspat)
CRT = readdata('exampleCRT.txt')
power(yC = 0.0148, yI = 0.0104, denom_per_cluster = 424, k = 0.29, Zsig = 1.96, Zpow = 0.8, c = 28,
sigma_r = 0, contaminate_pop_pr = 0, nearestDiscord = CRT$trial$nearestDiscord, distance_distribution = 'normal')
power <- function(yC, yI, denom_per_cluster, k, Zsig, Zpow = NULL, c = NULL,
sigma_r = 0, spillover_interval = 0, contaminate_pop_pr = NULL,
nearestDiscord = NULL, distance_distribution = 'normal'){
# The calculations can be adjusted for effects of spillover based on a diffusion model of mosquito movement. If no locations
# are provided an error function model of spillover is parameterized using either 'sigma_r' or 'contaminate_pop_pr'.
# The default is 'sigma_r = 0' corresponding to no spillover.
# If a set of randomized locations is provided in a trial data frame and 'contaminate_pop_pr > 0' or 'spillover_interval > 0' then the spillover is modeled based on the distribution of 'nearestDiscord'.
# if a normal approximation for the distances is required (distance_distribution = 'normal') then an analytical model parameterized using the
# standard deviation of 'nearestDiscord' is used to calculate the spillover bias 'delta'. If distance_distribution = 'empirical' then the empirical distribution of 'nearestDiscord' is used,
# and 'delta' is calculated by Monte Carlo integration.
if(!is.null(spillover_interval)) sigma_m <- spillover_interval/(2 * qnorm(0.975))
if(!is.null(nearestDiscord) & !identical(distance_distribution, 'empirical')) sigma_x <- sd(nearestDiscord)
if(!is.null(sigma_x) & !is.null(sigma_m)) sigma_r <- sigma_m/sigma_x
# If 'contaminate_pop_pr' is provided sigma_m based on the spillover interval is ignored
if(!is.null(contaminate_pop_pr)) sigma_r <- qnorm(0.025)/qnorm((1-contaminate_pop_pr)/2)
# calculate true efficacy
E <- 1 - yI/yC
# Compute bias only if sigma_r > 0
if (sigma_r > 0) {
# calculate delta
delta <- get_delta(X = list(E = E, sigma_r = sigma_r),
distance_distribution = distance_distribution,
nearestDiscord = nearestDiscord)
} else {
delta <- 0
}
# from Smith et al equation (23)
delta_t <- (delta * yC^2)/(yC + yI - delta*yC)
# use the formulae from Hayes & Bennett (1999) https://doi.org/10.1093/ije/28.2.319 as modified for spillover
den <- denom_per_cluster
if (!is.null(c)) {
# power with c clusters per arm and equal cluster sizes
Zpow <- sqrt((c - 1) * ((yC - yI + delta_t)^2)/((yC + yI)/den +
(k^2) * ((yC + delta_t/2)^2 + (yI - delta_t/2)^2))) - Zsig
clustersRequired <- 2 * c
}
}
power <- function(yC, yI, denom_per_cluster, k, Zsig, Zpow = NULL, c = NULL,
sigma_r = 0, spillover_interval = 0, contaminate_pop_pr = NULL,
nearestDiscord = NULL, distance_distribution = 'normal'){
# The calculations can be adjusted for effects of spillover based on a diffusion model of mosquito movement. If no locations
# are provided an error function model of spillover is parameterized using either 'sigma_r' or 'contaminate_pop_pr'.
# The default is 'sigma_r = 0' corresponding to no spillover.
# If a set of randomized locations is provided in a trial data frame and 'contaminate_pop_pr > 0' or 'spillover_interval > 0' then the spillover is modeled based on the distribution of 'nearestDiscord'.
# if a normal approximation for the distances is required (distance_distribution = 'normal') then an analytical model parameterized using the
# standard deviation of 'nearestDiscord' is used to calculate the spillover bias 'delta'. If distance_distribution = 'empirical' then the empirical distribution of 'nearestDiscord' is used,
# and 'delta' is calculated by Monte Carlo integration.
if(!is.null(spillover_interval)) sigma_m <- spillover_interval/(2 * qnorm(0.975))
if(!is.null(nearestDiscord) & !identical(distance_distribution, 'empirical')) sigma_x <- sd(nearestDiscord)
if(!is.null(sigma_x) & !is.null(sigma_m)) sigma_r <- sigma_m/sigma_x
# If 'contaminate_pop_pr' is provided sigma_m based on the spillover interval is ignored
if(!is.null(contaminate_pop_pr)) sigma_r <- qnorm(0.025)/qnorm((1-contaminate_pop_pr)/2)
# calculate true efficacy
E <- 1 - yI/yC
# Compute bias only if sigma_r > 0
if (sigma_r > 0) {
# calculate delta
delta <- get_delta(X = list(E = E, sigma_r = sigma_r),
distance_distribution = distance_distribution,
nearestDiscord = nearestDiscord)
} else {
delta <- 0
}
# from Smith et al equation (23)
delta_t <- (delta * yC^2)/(yC + yI - delta*yC)
# use the formulae from Hayes & Bennett (1999) https://doi.org/10.1093/ije/28.2.319 as modified for spillover
den <- denom_per_cluster
if (!is.null(c)) {
# power with c clusters per arm and equal cluster sizes
Zpow <- sqrt((c - 1) * ((yC - yI + delta_t)^2)/((yC + yI)/den +
(k^2) * ((yC + delta_t/2)^2 + (yI - delta_t/2)^2))) - Zsig
clustersRequired <- 2 * c
} else {
# clusters required (both arms)
clustersRequired <- 2 * ceiling(1 + (Zsig + Zpow)^2 * ((yC + yI)/den +
(k^2) * ((yC + delta_t/2)^2 + (yI - delta_t/2)^2))/((yC - yI + delta_t)^2))
}
power <- stats::pnorm(Zpow)
# the design effect is the ratio of the total denominator to that required for an individually randomized trial
# with no spillover
required_denom_RCT <- 2 * ((Zsig + Zpow)^2 * (yC + yI)/((yC - yI)^2))
DE <- den * clustersRequired/required_denom_RCT
returnlist <- list(power = power, clustersRequired = clustersRequired, DE = DE, delta = delta)
return(returnlist)
}
power(yC = 0.0148, yI = 0.0104, denom_per_cluster = 424, k = 0.29, Zsig = 1.96, Zpow = 0.8, c = 28,
sigma_r = 0, contaminate_pop_pr = 0, nearestDiscord = CRT$trial$nearestDiscord, distance_distribution = 'normal')
power(yC = 0.0148, yI = 0.0104, denom_per_cluster = 424, k = 0.29, Zsig = 1.96, Zpow = 0.8, c = 28,
sigma_r = 0, contaminate_pop_pr = 0.5, nearestDiscord = CRT$trial$nearestDiscord, distance_distribution = 'normal')
load_all()
devtools::load_all(".")
get_geom()
get_geom(CRT$trial, CRT$design)
get_geom(CRT$trial, CRT$design)
library(CRTspat)
library(CRTspat)
library(CRTspat)
? CRTpower
n
power(yC = 0.0148, yI = 0.0104, denom_per_cluster = 424, k = 0.29, Zsig = 1.96, Zpow = 0.8, c = 28,
sigma_r = 0, contaminate_pop_pr = 0.5, nearestDiscord = CRT$trial$nearestDiscord, distance_distribution = 'normal')
missing
? CRTpower
trial$nearestDiscord
is.null(trial$nearestDiscord)
Q
library(CRTspat)
? CRTpower
? CRTpower
