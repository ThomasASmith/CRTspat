formula, family = "binomial", Ntrials = y_off, lincomb = lc,
control.family = list(link = "logit"),
data = INLA::inla.stack.data(stk.full),
control.fixed = list(correlation.matrix = TRUE),
control.predictor = list(compute = TRUE, link = 1,
A = INLA::inla.stack.A(stk.full)),
control.compute = list(dic = TRUE))
inla.upgrade(testing=TRUE)
INLA::inla.upgrade(testing=TRUE)
remove.packages("INLA")
install.packages("INLA", repos="https://inla.r-inla-download.org/R/testing")
install.packages("INLA", repos = "https://inla.r-inla-download.org/R/testing")
library(CRTspat)
knitr::knit("vignettes/Usecase1.Rmd.orig", output = "vignettes/Usecase1.Rmd")
source("C:/git_repos/CRTspat/vignettes/runVignette.R")
knitr::knit("vignettes/Usecase1.Rmd.orig", output = "vignettes/Usecase1.Rmd")
remove.packages("INLA")
install.packages("INLA",repos=c(getOption("repos"),INLA="https://inla.r-inla-download.org/R/stable"), dep=TRUE)
install.packages("INLA", repos = c(getOption("repos"), INLA = "https://inla.r-inla-download.org/R/stable"), dep = TRUE)
library(CRTspat)
source("C:/git_repos/CRTspat/vignettes/runVignette.R")
set.seed(1234)
example_locations <- readdata('example_site.csv')
example_locations$base_denom <- 1
library(dplyr)
example_randomized <- CRTsp(example_locations) %>%
aggregateCRT(auxiliaries = c("RDT_test_result", "base_denom")) %>%
specify_clusters(h = 50, algorithm = 'NN') %>%
randomizeCRT(matchedPair = FALSE)
example2a <- simulateCRT(example_randomized,
effect = 0.8,
outcome0 = 0.5,
generateBaseline = FALSE,
baselineNumerator = "RDT_test_result",
baselineDenominator = "base_denom",
ICC_inp = 0.05, theta_inp = 0.8)
# Reading in the inla.mesh functions when run outside the check but not as part of a check
library(Matrix)
inla_mesh <- readdata("examplemesh100.rds")
analysis <- CRTanalysis(trial=example2a,
method = 'INLA', link='logit', cfunc='P',
personalProtection = TRUE, clusterEffects= TRUE,
requireMesh = TRUE, inla_mesh = inla_mesh)
analysis <- CRTanalysis(trial=example2a,
method = 'INLA', link='logit', cfunc='P',
personalProtection = TRUE, clusterEffects= TRUE,
requireMesh = TRUE, inla_mesh = inla_mesh)
n
analysis <- CRTanalysis(trial=example2a,
method = 'INLA', link='logit', cfunc='P',
personalProtection = TRUE, clusterEffects= TRUE,
requireMesh = TRUE, inla_mesh = inla_mesh)
fterms
inla_mesh$prediction$arm
library(CRTspat)
set.seed(1234)
example_locations <- readdata('example_site.csv')
example_locations$base_denom <- 1
library(dplyr)
example_randomized <- CRTsp(example_locations) %>%
aggregateCRT(auxiliaries = c("RDT_test_result", "base_denom")) %>%
specify_clusters(h = 50, algorithm = 'NN') %>%
randomizeCRT(matchedPair = FALSE)
example2a <- simulateCRT(example_randomized,
effect = 0.8,
outcome0 = 0.5,
generateBaseline = FALSE,
baselineNumerator = "RDT_test_result",
baselineDenominator = "base_denom",
ICC_inp = 0.05, theta_inp = 0.8)
# Reading in the inla.mesh functions when run outside the check but not as part of a check
library(Matrix)
inla_mesh <- readdata("examplemesh100.rds")
analysis <- CRTanalysis(trial=example2a,
method = 'INLA', link='logit', cfunc='P',
personalProtection = TRUE, clusterEffects= TRUE,
requireMesh = TRUE, inla_mesh = inla_mesh)
inla.upgrade(testing=TRUE)
INLA::inla.upgrade(testing=TRUE)
remove.packages("INLA")
install.packages("INLA", repos="https://inla.r-inla-download.org/R/testing")
install.packages("INLA", repos = "https://inla.r-inla-download.org/R/testing")
set.seed(1234)
example_locations <- readdata('example_site.csv')
example_locations$base_denom <- 1
library(dplyr)
example_randomized <- CRTsp(example_locations) %>%
aggregateCRT(auxiliaries = c("RDT_test_result", "base_denom")) %>%
specify_clusters(h = 50, algorithm = 'NN') %>%
randomizeCRT(matchedPair = FALSE)
example2a <- simulateCRT(example_randomized,
effect = 0.8,
outcome0 = 0.5,
generateBaseline = FALSE,
baselineNumerator = "RDT_test_result",
baselineDenominator = "base_denom",
ICC_inp = 0.05, theta_inp = 0.8)
library(CRTspat)
example_locations <- readdata('example_site.csv')
example_locations$base_denom <- 1
library(dplyr)
example_randomized <- CRTsp(example_locations) %>%
aggregateCRT(auxiliaries = c("RDT_test_result", "base_denom")) %>%
specify_clusters(h = 50, algorithm = 'NN') %>%
randomizeCRT(matchedPair = FALSE)
example2a <- simulateCRT(example_randomized,
effect = 0.8,
outcome0 = 0.5,
generateBaseline = FALSE,
baselineNumerator = "RDT_test_result",
baselineDenominator = "base_denom",
ICC_inp = 0.05, theta_inp = 0.8)
# Reading in the inla.mesh functions when run outside the check but not as part of a check
library(Matrix)
inla_mesh <- readdata("examplemesh100.rds")
analysis <- CRTanalysis(trial=example2a,
method = 'INLA', link='logit', cfunc='P',
personalProtection = TRUE, clusterEffects= TRUE,
requireMesh = TRUE, inla_mesh = inla_mesh)
inla_mesh <- compute_mesh(trial = example_randomized, pixel = 0.1)
# Reading in the inla.mesh functions when run outside the check but not as part of a check
library(Matrix)
inla_mesh <- readdata("examplemesh100.rds")
saveRDS(inla_mesh,file = "inst/extdata/examplemesh100.rds")
library(CRTspat)
saveRDS(inla_mesh,file = "inst/extdata/examplemesh100.rds")
library(CRTspat)
# Reading in the inla.mesh functions when run outside the check but not as part of a check
library(Matrix)
inla_mesh <- readdata("examplemesh100.rds")
analysis <- CRTanalysis(trial=example2a,
method = 'INLA', link='logit', cfunc='P',
personalProtection = TRUE, clusterEffects= TRUE,
requireMesh = TRUE, inla_mesh = inla_mesh)
install.packages("MatrixModels", type = "source")
install.packages("MatrixModels", type = "source")
library(CRTspat)
# Reading in the inla.mesh functions when run outside the check but not as part of a check
library(Matrix)
inla_mesh <- readdata("examplemesh100.rds")
analysis <- CRTanalysis(trial=example2a,
method = 'INLA', link='logit', cfunc='P',
personalProtection = TRUE, clusterEffects= TRUE,
requireMesh = TRUE, inla_mesh = inla_mesh)
source("C:/git_repos/CRTspat/vignettes/runVignette.R")
q()
rmarkdown.html_vignette.check_title = FALSE
devtools::install(build_vignettes = TRUE)
devtools::install(build_vignettes = TRUE)
devtools::install(build_vignettes = TRUE)
install.packages(cli)
install.packages("cli")
devtools::install(build_vignettes = TRUE)
install.packages("Rcpp")
devtools::install(build_vignettes = TRUE)
install.packages("stringi")
devtools::install(build_vignettes = TRUE)
q()
library(CRTspat)
library(CRTspat)
library(dplyr)
#results <- read.csv(file = "C:/Users/smith/Documents/documents/Current Projects/Multerer/binary_examples/simulations_bernoulli.csv")
#results$X <- NULL
# specify:
#   the number of simulations required
#   a large number e.g. 10,000 for the definitive analysis)
nsimulations <- 10
# 33% of simulations have zero efficacy, the remainder have efficacy drawn from a uniform distribution (0, 0.6)
ranuni <- runif(nsimulations,0,0.9)
effect <- ifelse(ranuni > 0.6, 0, ranuni)
# vector of input range of contamination
theta_inp <- runif(nsimulations, min = 0, max = 1.5)
#   desired efficacy;
#   prevalence in the absence of intervention;
#   anticipated ICC;
#   clusters in each arm
outcome0 <- runif(nsimulations, 0.2, 0.8)
ICC <- runif(nsimulations, 0.02, 0.08)
logc <- runif(nsimulations, log(5), log(200))
c <- round(exp(logc))
input <- data.frame(effect = effect, theta_inp = theta_inp, ICC = ICC, c = c, outcome0 = outcome0)
# a user function randomizes and analyses each simulated trial
CRTscenario7 <- function(input) {
print(input)
ex <- specify_clusters(CRT, c = input[["c"]], algo = "kmeans") %>%
randomizeCRT() %>%
simulateCRT(effect = input[["effect"]], generateBaseline = FALSE, outcome0 = input[["outcome0"]],
ICC_inp = input[["ICC"]], theta_inp = input[["theta_inp"]],
matchedPair = FALSE, scale = "proportion", denominator = "denom", tol = 0.01)
examplePower = CRTpower(trial = ex, desiredPower = 0.8,
effect=input[["effect"]], yC=input[["outcome0"]],
outcome_type = 'd', ICC = input[["ICC"]], c = input[["c"]])
nominalpower <-  examplePower$geom_full$power
sd <- input[["theta_inp"]]/(2 * qnorm(0.975))
contaminate_pop_pr_input <- sum(abs(ex$trial$nearestDiscord) < 0.5 * input[["theta_inp"]])/nrow(ex$trial)
contaminate_pop_pr_sd <- sum(abs(ex$trial$nearestDiscord) < input[["theta_inp"]]/(2 * qnorm(0.975)))/nrow(ex$trial)
Tanalysis <- CRTanalysis(ex, method = "T")
Ganalysis <- CRTanalysis(ex, method = "GEE")
tryCatch(
Lanalysis <- CRTanalysis(ex, method = "LME4", cfunc = 'L')
)
Zanalysis <- CRTanalysis(ex, method = "LME4", cfunc = 'Z')
climits <- Lanalysis$contamination$contamination_limits
value <- c(
c = input[["c"]],
outcome0 = input[["outcome0"]],
effect = input[["effect"]],
theta_inp = input[["theta_inp"]],
ICC_input = input[["ICC"]],
ICC_estimated = Ganalysis$pt_ests$ICC,
cv_percent = Tanalysis$description$cv_percent,
nominalpower = examplePower$geom_full$power,
contaminate_pop_pr_input = contaminate_pop_pr_input,
contaminate_pop_pr_sd = contaminate_pop_pr_sd,
Pvalue_t = Tanalysis$pt_ests$p.value,
Ldeviance = Lanalysis$pt_ests$deviance,
Zdeviance = Zanalysis$pt_ests$deviance,
effect_size_t = Tanalysis$pt_ests$effect_size,
effect_size_G = Ganalysis$pt_ests$effect_size,
effect_size_L = Lanalysis$pt_ests$effect_size,
contamination_interval = Lanalysis$pt_ests$contamination_interval,
contaminate_pop_pr = Lanalysis$contamination$contaminate_pop_pr)
return(value)
}
CRTscenario7(input[1,])
### EVALUATION OF TYPE I AND TYPE II ERROR RATES (ROC ANALYSIS)
library(CRTspat)
# use the locations only from example dataset. The cluster, arm, and outcome assignments will be replaced
example <- readdata("exampleCRT.txt")
example$trial$denom <- example$trial$base_denom
trial <- example$trial[ , c("x","y", "denom")]
trial$propensity <- 1
CRT <- CRTsp(trial)
library(dplyr)
#results <- read.csv(file = "C:/Users/smith/Documents/documents/Current Projects/Multerer/binary_examples/simulations_bernoulli.csv")
#results$X <- NULL
# specify:
#   the number of simulations required
#   a large number e.g. 10,000 for the definitive analysis)
nsimulations <- 10
# 33% of simulations have zero efficacy, the remainder have efficacy drawn from a uniform distribution (0, 0.6)
ranuni <- runif(nsimulations,0,0.9)
effect <- ifelse(ranuni > 0.6, 0, ranuni)
# vector of input range of contamination
theta_inp <- runif(nsimulations, min = 0, max = 1.5)
#   desired efficacy;
#   prevalence in the absence of intervention;
#   anticipated ICC;
#   clusters in each arm
outcome0 <- runif(nsimulations, 0.2, 0.8)
ICC <- runif(nsimulations, 0.02, 0.08)
logc <- runif(nsimulations, log(5), log(200))
c <- round(exp(logc))
input <- data.frame(effect = effect, theta_inp = theta_inp, ICC = ICC, c = c, outcome0 = outcome0)
# a user function randomizes and analyses each simulated trial
CRTscenario7(input[1,])
CRTscenario7(input[1,])
summary(CRT$trial$propensity)
library(CRTspat)
# use the locations only from example dataset. The cluster, arm, and outcome assignments will be replaced
example <- readdata("exampleCRT.txt")
example$trial$denom <- example$trial$base_denom
trial <- example$trial[ , c("x","y", "denom")]
trial$propensity <- NULL
CRT <- CRTsp(trial)
library(dplyr)
#results <- read.csv(file = "C:/Users/smith/Documents/documents/Current Projects/Multerer/binary_examples/simulations_bernoulli.csv")
#results$X <- NULL
# specify:
#   the number of simulations required
#   a large number e.g. 10,000 for the definitive analysis)
nsimulations <- 10
# 33% of simulations have zero efficacy, the remainder have efficacy drawn from a uniform distribution (0, 0.6)
ranuni <- runif(nsimulations,0,0.9)
effect <- ifelse(ranuni > 0.6, 0, ranuni)
# vector of input range of contamination
theta_inp <- runif(nsimulations, min = 0, max = 1.5)
#   desired efficacy;
#   prevalence in the absence of intervention;
#   anticipated ICC;
#   clusters in each arm
outcome0 <- runif(nsimulations, 0.2, 0.8)
ICC <- runif(nsimulations, 0.02, 0.08)
logc <- runif(nsimulations, log(5), log(200))
c <- round(exp(logc))
input <- data.frame(effect = effect, theta_inp = theta_inp, ICC = ICC, c = c, outcome0 = outcome0)
CRTscenario7(input[1,])
baselineNumerator
baselineNumerator='base_num'
baselineDenominator='base_denom'
trial$base_denom <- rpois(1181, 1.5)
trial$base_num <- dbin(1181, )
trial$base_num <- sample(1181, size = 500, replace = FALSE)
trial$base_num <- sample(trial$base_denom, size = 1181, replace = FALSE)
summary(trial$base_num)
summary(trial$base_num/trial$base_denom)
summary(trial$base_denom)
trial$base_denom[trial$base_denom == 0] <- 1
summary(trial$base_num/trial$base_denom)
# expand the vector of locations to allow for denominators > 1
trial <- dplyr::mutate(trial, kernelID = dplyr::row_number())
kernels$weight <- 1/kernels[[baselineDenominator]]
kernels  <- tidyr::uncount(trial, trial[[baselineNumerator]])
kernels$weight <- 1/kernels[[baselineDenominator]]
View(kernels)
kernels
kernels <- 200
? sample
sample(c(1,4,6,7,9,12), size = 4, replace = TRUE)
sample(c(1,4,6,7,9,12), size = 4, replace = FALSE)
library(CRTspat)
CRTscenario7(input[1,])
CRT$trial$propensity
library(CRTspat)
CRTscenario7(input[1,])
CRT$trial$propensity
CRTscenario7(input[1,])
CRT$trial$propensity
library(CRTspat)
CRTscenario7(input[1,])
CRTscenario7(input[1,])
CRTscenario7(input[1,])
CRTscenario7(input[1,])
determineKernelCenters(trial = trial, kernels = kernels)
library(CRTspat)
CRTscenario7(input[1,])
library(CRTspat)
CRTscenario7(input[1,])
? tidyr::uncount
library(CRTspat)
CRTscenario7(input[1,])
CRTscenario7(input[1,])
test_Clusters <- specify_clusters(readdata("example_site.csv"),h = 50)
test_Arms <- randomizeCRT(trial = test_Clusters,matchedPair = TRUE)
test_simulateCRT <- simulateCRT(trial = test_Arms,
theta_inp = 1.2,outcome0 = 0.4,
ICC_inp = 0.05 ,effect = 0.4, tol = 0.05)
test_Arms
test_Clusters <- specify_clusters(readdata("example_site.csv"),h = 50)
test_Arms <- randomizeCRT(trial = test_Clusters,matchedPair = TRUE)
test_simulateCRT <- simulateCRT(trial = test_Arms,
theta_inp = 1.2,outcome0 = 0.4,
ICC_inp = 0.05 ,effect = 0.4, tol = 0.05, baselineNumerator = 'RDT_test_result')
centers
library(CRTspat)
test_Clusters <- specify_clusters(readdata("example_site.csv"),h = 50)
test_Arms <- randomizeCRT(trial = test_Clusters,matchedPair = TRUE)
test_simulateCRT <- simulateCRT(trial = test_Arms,
theta_inp = 1.2,outcome0 = 0.4,
ICC_inp = 0.05 ,effect = 0.4, tol = 0.05, baselineNumerator = 'RDT_test_result')
sampled_kernels
test_Clusters <- specify_clusters(readdata("example_site.csv"),h = 50)
test_Arms <- randomizeCRT(trial = test_Clusters,matchedPair = TRUE)
test_simulateCRT <- simulateCRT(trial = test_Arms,
theta_inp = 1.2,outcome0 = 0.4,
ICC_inp = 0.05 ,effect = 0.4, tol = 0.05, baselineNumerator = 'RDT_test_result')
table(sampledkernels)
possible_kernels
possible_kernels
centers <- sample(x = nrow(possible_kernels), size = kernels, replace = FALSE)
table(trial$RDT_test_result[centers])
table(trial$RDT_test_result)
trial <- CRT$trial
# If baseline numerator data exist and propensity doesn't
if (!(baselineDenominator %in% colnames(trial))){
trial[[baselineDenominator]] <- 1
}
# expand the vector of locations to allow for denominators > 1
trial_copy <- dplyr::mutate(trial, kernelID = dplyr::row_number()) %>%
tidyr::uncount(trial[[baselineNumerator]])
View(trial_copy)
# expand the vector of locations to allow for denominators > 1
trial_copy <- dplyr::mutate(trial, kernelID = dplyr::row_number()) %>%
tidyr::uncount(trial_copy[[baselineNumerator]])
# expand the vector of locations to allow for denominators > 1
trial_copy <- dplyr::mutate(trial, kernelID = dplyr::row_number()) %>%
tidyr::uncount(trial_copy[[baselineNumerator]])
# expand the vector of locations to allow for denominators > 1
trial_copy <- dplyr::mutate(trial, kernelID = dplyr::row_number()) %>%
trial_copy <- tidyr::uncount(trial_copy, trial_copy[[baselineNumerator]])
# expand the vector of locations to allow for denominators > 1
trial_copy <- dplyr::mutate(trial, kernelID = dplyr::row_number())
trial_copy <- tidyr::uncount(trial_copy, trial_copy[[baselineNumerator]])
trial_copy$weight <- 1/trial_copy[[baselineDenominator]]
# If baseline numerator data exist and propensity doesn't
if (!(baselineDenominator %in% colnames(trial))){
trial[[baselineDenominator]] <- 1
}
# expand the vector of locations to allow for denominators > 1
trial_copy <- dplyr::mutate(trial, kernelID = dplyr::row_number())
trial_copy <- tidyr::uncount(trial_copy, trial_copy[[baselineNumerator]])
trial_copy$weight <- 1/trial_copy[[baselineDenominator]]
# If baseline numerator data exist and propensity doesn't
if (!(baselineDenominator %in% colnames(trial))){
trial[[baselineDenominator]] <- 1
}
# expand the vector of locations to allow for denominators > 1
trial_copy <- dplyr::mutate(trial, kernelID = dplyr::row_number())
trial_copy <- tidyr::uncount(trial_copy, trial_copy[[baselineNumerator]])
trial_copy$weight <- 1/trial_copy[[baselineDenominator]]
trial[[baselineDenominator]]
# If baseline numerator data exist and propensity doesn't
if (is.null(trial[[baselineDenominator]])) trial[[baselineDenominator]] <- 1
# expand the vector of locations to allow for denominators > 1
trial_copy <- dplyr::mutate(trial, kernelID = dplyr::row_number())
trial_copy <- tidyr::uncount(trial_copy, trial_copy[[baselineNumerator]])
trial_copy$weight <- 1/trial_copy[[baselineDenominator]]
# If baseline numerator data exist and propensity doesn't
if (is.null(trial[[baselineDenominator]])) trial[[baselineDenominator]] <- rep(1, nrow(trial))
# expand the vector of locations to allow for denominators > 1
trial_copy <- dplyr::mutate(trial, kernelID = dplyr::row_number())
trial_copy <- tidyr::uncount(trial_copy, trial_copy[[baselineNumerator]])
trial_copy$weight <- 1/trial_copy[[baselineDenominator]]
View(trial)
baselineDenominator
trial[[baselineDenominator]] <- rep(1, nrow(trial))
trial <- CRT$trial
is.null(trial[[baselineDenominator]])
# If baseline numerator data exist and propensity doesn't
if (is.null(trial[[baselineDenominator]])) trial[[baselineDenominator]] <- rep(1, nrow(trial))
# expand the vector of locations to allow for denominators > 1
trial_copy <- dplyr::mutate(trial, kernelID = dplyr::row_number())
rep(1, nrow(trial))
# If baseline numerator data exist and propensity doesn't
if (!baselineDenominator %in% colnames(trial)) trial[[baselineDenominator]] <- rep(1, nrow(trial))
# If baseline numerator data exist and propensity doesn't
if (!(baselineDenominator %in% colnames(trial))) trial[[baselineDenominator]] <- rep(1, nrow(trial))
trial[[baselineDenominator]] <- rep(1, nrow(trial))
!(baselineDenominator %in% colnames(trial))
trial <- CRT$trial
# If baseline numerator data exist and propensity doesn't
if (!(baselineDenominator %in% colnames(trial))) {
trial[[baselineDenominator]] <- rep(1, nrow(trial))
}
!(baselineDenominator %in% colnames(trial))
# If baseline numerator data exist and propensity doesn't
if (!(baselineDenominator %in% colnames(trial))) {
trial[[baselineDenominator]] <- rep(1, nrow(trial))
}
# If baseline numerator data exist and propensity doesn't
if (!(baselineDenominator %in% colnames(trial))) {
trial$base_denom <- rep(1, nrow(trial))
}
# If baseline numerator data exist and propensity doesn't
ifelse(is.null(trial[[baselineDenominator]]), 1, trial[[baselineDenominator]])
# If baseline numerator data exist and propensity doesn't
trial[[baselineDenominator]] <- ifelse(is.null(trial[[baselineDenominator]]), 1, trial[[baselineDenominator]])
trial <- CRT$trial
# If baseline numerator data exist and propensity doesn't
trial[[baselineDenominator]] <- ifelse(is.null(trial[[baselineDenominator]]), 1, trial[[baselineDenominator]])
# expand the vector of locations to allow for denominators > 1
trial_copy <- dplyr::mutate(trial, kernelID = dplyr::row_number())
trial_copy <- tidyr::uncount(trial_copy, trial_copy[[baselineNumerator]])
trial_copy$weight <- 1/trial_copy[[baselineDenominator]]
possible_kernels <- tidyr::uncount(trial, round(trial[[baselineNumerator]]))
? tidyr::weight
? tidyr::uncount
# expand the vector of locations to allow for denominators > 1
possible_kernels <- dplyr::mutate(trial, kernelID = dplyr::row_number())
# expand the vector of locations to allow for denominators > 1
possible_kernels <- dplyr::mutate(trial, kernelID = dplyr::row_number())
# expand the vector of locations to allow for denominators > 1
possible_kernels <- dplyr::mutate(trial, kernelID = dplyr::row_number())
possible_kernels <- tidyr::uncount(possible_kernels, round(trial_copy[[baselineNumerator]]))
# If baseline numerator data exist and propensity doesn't
trial[[baselineDenominator]] <- ifelse(is.null(trial[[baselineDenominator]]), 1, trial[[baselineDenominator]])
# expand the vector of locations to allow for denominators > 1
possible_kernels <- dplyr::mutate(trial, kernelID = dplyr::row_number())
possible_kernels <- tidyr::uncount(possible_kernels, round(possible_kernels[[baselineNumerator]]))
centers <- sample(x = nrow(possible_kernels), size = kernels, replace = FALSE)
# expand the vector of locations to allow for denominators > 1
possible_kernels <- dplyr::mutate(trial, kernelID = dplyr::row_number())
possible_kernels$propensity <- round(10 * possible_kernels[[baselineNumerator]]/possible_kernels[[baselineDenominator]])
possible_kernels <- tidyr::uncount(possible_kernels, possible_kernels$propensity)
centers <- sample(x = nrow(possible_kernels), size = kernels, replace = FALSE)
# expand the vector of locations to allow for denominators > 1
possible_kernels <- dplyr::mutate(trial, kernelID = dplyr::row_number())
possible_kernels$propensity <- round(10 * possible_kernels[[baselineNumerator]]/possible_kernels[[baselineDenominator]])
possible_kernels <- tidyr::uncount(possible_kernels, possible_kernels$propensity)
centers <- possible_kernels$kernelID[sample(x = nrow(possible_kernels), size = kernels, replace = FALSE)]
centers <- sample(1:nrow(trial), size = kernels, replace = TRUE)
summary(centers)
centers <- possible_kernels$kernelID[sample(x = nrow(possible_kernels), size = kernels, replace = FALSE)]
summary(centers)
library(CRTspat)
test_Clusters <- specify_clusters(readdata("example_site.csv"),h = 50)
test_Arms <- randomizeCRT(trial = test_Clusters,matchedPair = TRUE)
test_simulateCRT <- simulateCRT(trial = test_Arms,
theta_inp = 1.2,outcome0 = 0.4,
ICC_inp = 0.05 ,effect = 0.4, tol = 0.05, baselineNumerator = 'RDT_test_result')
test_Clusters <- specify_clusters(readdata("example_site.csv"),h = 50)
test_Arms <- randomizeCRT(trial = test_Clusters,matchedPair = TRUE)
test_simulateCRT <- simulateCRT(trial = test_Arms,
theta_inp = 1.2,outcome0 = 0.4, kernels = 20,
ICC_inp = 0.05 ,effect = 0.4, tol = 0.05, baselineNumerator = 'RDT_test_result')
CRTscenario7(input[1,])
install.packages(c("aod", "BH", "brew", "checkmate", "coda", "commonmark", "cowplot", "curl", "data.table", "DBI", "dbplyr", "DEoptimR", "DescTools", "deSolve", "DiagrammeR", "digest", "dotCall64", "expm", "FNN", "foreign", "gdata", "geepack", "gert", "ggrepel", "ggthemes", "glue", "gtools", "haven", "htmlwidgets", "httpuv", "httr2", "igraph", "inlabru", "jagsUI", "ks", "later", "lubridate", "maps", "markdown", "Matrix", "matrixStats", "mclust", "mcmc", "MCMCpack", "mlr3misc", "multicool", "mvtnorm", "openssl", "pcaPP", "pkgload", "plot3D", "pracma", "progress", "ps", "ragg", "rainbow", "rbibutils", "RCurl", "Rdpack", "readr", "reprex", "rgl", "rJava", "rlang", "robustbase", "rootSolve", "roxygen2", "rrcov", "shiny", "sp", "spacetime", "spam", "spatstat", "spatstat.data", "spatstat.explore", "spatstat.geom", "spatstat.linnet", "spatstat.model", "spatstat.sparse", "spdep", "systemfonts", "terra", "textshaping", "tgp", "tidyr", "tidyterra", "timechange", "uuid", "viridis", "vroom", "withr", "xfun", "XML", "xml2", "xts", "zip"))
install.packages(c("aod", "BH", "brew", "checkmate", "coda", "commonmark", "cowplot", "curl", "data.table", "DBI", "dbplyr", "DEoptimR", "DescTools", "deSolve", "DiagrammeR", "digest", "dotCall64", "expm", "FNN", "foreign", "gdata", "geepack", "gert", "ggrepel", "ggthemes", "glue", "gtools", "haven", "htmlwidgets", "httpuv", "httr2", "igraph", "inlabru", "jagsUI", "ks", "later", "lubridate", "maps", "markdown", "Matrix", "matrixStats", "mclust", "mcmc", "MCMCpack", "mlr3misc", "multicool", "mvtnorm", "openssl", "pcaPP", "pkgload", "plot3D", "pracma", "progress", "ps", "ragg", "rainbow", "rbibutils", "RCurl", "Rdpack", "readr", "reprex", "rgl", "rJava", "rlang", "robustbase", "rootSolve", "roxygen2", "rrcov", "shiny", "sp", "spacetime", "spam", "spatstat", "spatstat.data", "spatstat.explore", "spatstat.geom", "spatstat.linnet", "spatstat.model", "spatstat.sparse", "spdep", "systemfonts", "terra", "textshaping", "tgp", "tidyr", "tidyterra", "timechange", "uuid", "viridis", "vroom", "withr", "xfun", "XML", "xml2", "xts", "zip"))
install.packages(c("aod", "BH", "brew", "checkmate", "coda", "commonmark", "cowplot", "curl", "data.table", "DBI", "dbplyr", "DEoptimR", "DescTools", "deSolve", "DiagrammeR", "digest", "dotCall64", "expm", "FNN", "foreign", "gdata", "geepack", "gert", "ggrepel", "ggthemes", "glue", "gtools", "haven", "htmlwidgets", "httpuv", "httr2", "igraph", "inlabru", "jagsUI", "ks", "later", "lubridate", "maps", "markdown", "Matrix", "matrixStats", "mclust", "mcmc", "MCMCpack", "mlr3misc", "multicool", "mvtnorm", "openssl", "pcaPP", "pkgload", "plot3D", "pracma", "progress", "ps", "ragg", "rainbow", "rbibutils", "RCurl", "Rdpack", "readr", "reprex", "rgl", "rJava", "rlang", "robustbase", "rootSolve", "roxygen2", "rrcov", "shiny", "sp", "spacetime", "spam", "spatstat", "spatstat.data", "spatstat.explore", "spatstat.geom", "spatstat.linnet", "spatstat.model", "spatstat.sparse", "spdep", "systemfonts", "terra", "textshaping", "tgp", "tidyr", "tidyterra", "timechange", "uuid", "viridis", "vroom", "withr", "xfun", "XML", "xml2", "xts", "zip"))
install.packages(c("aod", "BH", "brew", "checkmate", "coda", "commonmark", "cowplot", "curl", "data.table", "DBI", "dbplyr", "DEoptimR", "DescTools", "deSolve", "DiagrammeR", "digest", "dotCall64", "expm", "FNN", "foreign", "gdata", "geepack", "gert", "ggrepel", "ggthemes", "glue", "gtools", "haven", "htmlwidgets", "httpuv", "httr2", "igraph", "inlabru", "jagsUI", "ks", "later", "lubridate", "maps", "markdown", "Matrix", "matrixStats", "mclust", "mcmc", "MCMCpack", "mlr3misc", "multicool", "mvtnorm", "openssl", "pcaPP", "pkgload", "plot3D", "pracma", "progress", "ps", "ragg", "rainbow", "rbibutils", "RCurl", "Rdpack", "readr", "reprex", "rgl", "rJava", "rlang", "robustbase", "rootSolve", "roxygen2", "rrcov", "shiny", "sp", "spacetime", "spam", "spatstat", "spatstat.data", "spatstat.explore", "spatstat.geom", "spatstat.linnet", "spatstat.model", "spatstat.sparse", "spdep", "systemfonts", "terra", "textshaping", "tgp", "tidyr", "tidyterra", "timechange", "uuid", "viridis", "vroom", "withr", "xfun", "XML", "xml2", "xts", "zip"))
install.packages(c("aod", "BH", "brew", "checkmate", "coda", "commonmark", "cowplot", "curl", "data.table", "DBI", "dbplyr", "DEoptimR", "DescTools", "deSolve", "DiagrammeR", "digest", "dotCall64", "expm", "FNN", "foreign", "gdata", "geepack", "gert", "ggrepel", "ggthemes", "glue", "gtools", "haven", "htmlwidgets", "httpuv", "httr2", "igraph", "inlabru", "jagsUI", "ks", "later", "lubridate", "maps", "markdown", "Matrix", "matrixStats", "mclust", "mcmc", "MCMCpack", "mlr3misc", "multicool", "mvtnorm", "openssl", "pcaPP", "pkgload", "plot3D", "pracma", "progress", "ps", "ragg", "rainbow", "rbibutils", "RCurl", "Rdpack", "readr", "reprex", "rgl", "rJava", "rlang", "robustbase", "rootSolve", "roxygen2", "rrcov", "shiny", "sp", "spacetime", "spam", "spatstat", "spatstat.data", "spatstat.explore", "spatstat.geom", "spatstat.linnet", "spatstat.model", "spatstat.sparse", "spdep", "systemfonts", "terra", "textshaping", "tgp", "tidyr", "tidyterra", "timechange", "uuid", "viridis", "vroom", "withr", "xfun", "XML", "xml2", "xts", "zip"))
install.packages("rlang")
install.packages("rlang")
install.packages("rlang")
install.packages("dplyr","Matrix")
install.packages("Matrix")
install.packages("Matrix")
install.packages("rlang")
install.packages("rlang")
install.packages("rlang")
install.packages("rlang")
install.packages("rlang")
