rownames(output)[4] <- "Locations:                                            "
if(identical(object$geom_full$locations,object$geom_full$records)){
output[4, 1] <- object$geom_full$locations
} else {
if(!is.null(object$geom_full$records)) {
rownames(output)[4] <- paste0("Not aggregated. Total records: ",
object$geom_full$records,". Unique locations:")
}
output[4, 1] <- object$geom_full$locations
}
if (object$geom_core$locations > 0) {
output[1, 1] <- "Full"
output[1, 2] <- "Core"
output[4, 2] <- object$geom_core$locations
if (!is.na(object$geom_core$mean_h)) {
clustersAvailableCore <- with(object$geom_core, floor(locations/mean_h))
output[5, 2] <- clustersAvailableCore
output[6, 2] <- round(object$geom_core$mean_h, digits = 1)
}
if (!is.null(object$geom_core$sd_h))
output[7, 2] <- round(object$geom_core$sd_h, digits = 1)
}
if (!is.null(object$trial$arm) & !identical(object$trial$arm,character(0))) {
sd1 <- ifelse(is.null(object$geom_full$sd_distance), NA, object$geom_full$sd_distance)
sd2 <- ifelse(is.null(object$geom_core$sd_distance), NA, object$geom_core$sd_distance)
rownames(output)[8] <- "S.D. of distance to nearest discordant location (km): "
output[8, 1] <- ifelse(is.na(sd1), "", round(sd1, digits = 2))
output[8, 2] <- ifelse(is.na(sd2), "", round(sd2, digits = 2))
rownames(output)[9] <- "Cluster randomization:            "
if (is.null(object$trial$pair)) {
output[9, 1] <- "Independently randomized"
} else {
output[9, 1] <- "Matched pairs randomized"
}
} else {
if (is.null(object$trial$x)) {
rownames(output)[9] <- "No locations to randomize"
} else {
rownames(output)[9] <- "No randomization"
}
output[9, 1] <- "-"
}
if (!is.null(object$design$alpha)) {
rownames(output)[10] <- "\nSpecification of Requirements\n-----------------------------"
output[10, 1] <- "-"
rownames(output)[11] <- "Significance level (2-sided):    "
output[11, 1] <- object$design$alpha
rownames(output)[12] <- "Type of Outcome                   "
output[12, 1] <- switch(object$design$outcome_type,
'y' = "continuous",
"n" = "count",
"e" = "event rate",
'p' = "proportion",
'd' = "dichotomous")
rownames(output)[13] <- "Expected outcome in control arm:  "
output[13, 1] <- object$design$yC
link <- switch(object$design$outcome_type,
'y' = "identity",
"n" = "log",
"e" = "log",
'p' = "logit",
'd' = "logit")
rownames(output)[14] <- switch(link,
"identity" = "Expected variance of outcome:     ",
"log" = "Mean rate multiplier:             ",
"cloglog" = "Mean rate multiplier:             ",
"logit" = "Mean denominator:                 ")
output[14, 1] <- switch(link,
"identity" =  object$design$sigma2,
"log" = object$design$denominator,
"cloglog" = object$design$denominator,
"logit" = object$design$N)
if (identical(object$design$outcome_type, 'd')) output[14, 1] <- ""
rownames(output)[15] <- "Required effect size:             "
output[15, 1] <- object$design$effect
rownames(output)[16] <- "Intra-cluster correlation:        "
output[16, 1] <- object$design$ICC
if (!is.null(object$design$buffer_width)) {
rownames(output)[3] <- "Buffer width :               "
if (object$design$buffer_width > 0) {
output[3, 1] <- paste0(object$design$buffer_width,
" km.")
} else {
output[3, 1] <- "No buffer"
}
}
}
output[17, 1] <- "-"
if (is.null(object$design$effect)) {
rownames(output)[17] <- "No power calculations to report"
} else {
rownames(output)[17] <- "\nPower calculations (ignoring contamination)\n------------------                    "
sufficient <- ifelse(clustersAvailableFull >= object$geom_full$clustersRequired,
"Yes", "No")
rownames(output)[18] <- "Design effect:                         "
output[18, 1] <- round(object$geom_full$DE, digits = 1)
rownames(output)[19] <- "Nominal power (%)                      "
output[19, 1] <- round(object$geom_full$power * 100, digits = 1)
rownames(output)[20] <- paste0("Total clusters required (power of ",
object$design$desiredPower * 100, "%):")
output[20, 1] <- object$geom_full$clustersRequired
rownames(output)[21] <- "Sufficient clusters for required power?"
output[21, 1] <- sufficient
if (is.null(object$geom_core$power)) {
output <- subset(output, select = -c(2))
} else {
output[17, 1] <- "Full"
output[17, 2] <- "Core"
clustersAvailableCore <- with(object$geom_core, floor(locations/mean_h))
sufficientCore <- ifelse(clustersAvailableCore >= object$geom_core$clustersRequired,
"Yes", "No")
output[18, 2] <- round(object$geom_core$DE, digits = 1)
output[19, 2] <- round(object$geom_core$power * 100, digits = 1)
output[20, 2] <- object$geom_core$clustersRequired
output[21, 2] <- sufficientCore
}
}
standard.names <- c("x", "y", "cluster", "arm", "buffer", "nearestDiscord",
"geom_full", "geom_core", "design")
rownames(output)[22] <- "\nOther variables in dataset\n--------------------------"
output[22, 1] <- paste(dplyr::setdiff(names(object$trial), standard.names), collapse = "  ")
rownames(output)
output[trimws(output[, 1]) != "", ]
library(CRTspat)
examplePower2 = CRTpower(locations = 2000, cv_percent = 40, effect = 0.4, denominator = 2.5, alpha = 0.05,
outcome_type = 'e', desiredPower = 0.8, yC = 0.35, c = 20, sd_h=5)
summary(examplePower2)
examplePower2 = CRTpower(locations = 2000, cv_percent = 40, effect = 0.4, denominator = 2.5, alpha = 0.05,
outcome_type = 'e', desiredPower = 0.8, yC = 0.35, c = 20, sd_h=5)
object <- examplePower2
defaultdigits <- getOption("digits")
on.exit(options(digits = defaultdigits))
options(digits = 3)
cat("===============================CLUSTER RANDOMISED TRIAL ===========================\n")
output <- matrix("  ", nrow = 22, ncol = 2)
rownames(output) <- paste0("row ", 1:nrow(output))
rownames(output)[1] <- "Locations and Clusters\n----------------------                                "
output[1, 1] <- "-"
rownames(output)[2] <- "Coordinate system            "
if (length(object$trial$x) > 0 & length(object$trial$y) > 0) {
output[2, 1] <- "(x, y)"
} else if(!is.null(object$trial$lat)) {
output[2, 1] <- "Lat-Long"
} else {
output[2, 1] <- "No coordinates in dataset"
}
if (identical(unname(output[2, 1]),"(x, y)")) {
cat("\nSummary of coordinates\n----------------------\n")
coordinate.summary <- with(object$trial, summary(cbind(x, y)))
rownames(coordinate.summary) <- substr(coordinate.summary[, 1], 1, 8)
coordinate.summary[, ] <- substr(coordinate.summary[, ], 9, 13)
print(t(coordinate.summary))
xycoords <- data.frame(cbind(x=object$trial$x,y=object$trial$y))
tr <- sf::st_as_sf(xycoords, coords = c("x","y"))
buf1 <- sf::st_buffer(tr, maskbuffer)
buf2 <- sf::st_union(buf1)
area <- sf::st_area(buf2)
cat("Total area (within ", maskbuffer,"km of a location) : ", area, "sq.km\n\n")
if (!is.null(object$geom_full$centroid)) {
cat("Geolocation of centroid (radians):
latitude: ", object$geom_full$centroid$lat,
"longitude: ", object$geom_full$centroid$long,"\n\n")
}
}
rownames(output)[5] <- "Available clusters (across both arms)                 "
if (is.na(object$geom_full$c)) {
output[5, 1] <- "Not assigned"
} else {
clustersAvailableFull <- with(object$geom_full, floor(locations/mean_h))
output[5, 1] <- clustersAvailableFull
rownames(output)[6] <- "  Per cluster mean number of points                   "
output[6, 1] <- round(object$geom_full$mean_h, digits = 1)
rownames(output)[7] <- "  Per cluster s.d. number of points                   "
if (!is.null(object$geom_full$sd_h))
output[7, 1] <- round(object$geom_full$sd_h, digits = 1)
}
rownames(output)[4] <- "Locations:                                            "
if(identical(object$geom_full$locations,object$geom_full$records)){
output[4, 1] <- object$geom_full$locations
} else {
if(!is.null(object$geom_full$records)) {
rownames(output)[4] <- paste0("Not aggregated. Total records: ",
object$geom_full$records,". Unique locations:")
}
output[4, 1] <- object$geom_full$locations
}
if (object$geom_core$locations > 0) {
output[1, 1] <- "Full"
output[1, 2] <- "Core"
output[4, 2] <- object$geom_core$locations
if (!is.na(object$geom_core$mean_h)) {
clustersAvailableCore <- with(object$geom_core, floor(locations/mean_h))
output[5, 2] <- clustersAvailableCore
output[6, 2] <- round(object$geom_core$mean_h, digits = 1)
}
if (!is.null(object$geom_core$sd_h))
output[7, 2] <- round(object$geom_core$sd_h, digits = 1)
}
if (!is.null(object$trial$arm) & !identical(object$trial$arm,character(0))) {
sd1 <- ifelse(is.null(object$geom_full$sd_distance), NA, object$geom_full$sd_distance)
sd2 <- ifelse(is.null(object$geom_core$sd_distance), NA, object$geom_core$sd_distance)
rownames(output)[8] <- "S.D. of distance to nearest discordant location (km): "
output[8, 1] <- ifelse(is.na(sd1), "", round(sd1, digits = 2))
output[8, 2] <- ifelse(is.na(sd2), "", round(sd2, digits = 2))
rownames(output)[9] <- "Cluster randomization:            "
if (is.null(object$trial$pair)) {
output[9, 1] <- "Independently randomized"
} else {
output[9, 1] <- "Matched pairs randomized"
}
} else {
if (is.null(object$trial$x)) {
rownames(output)[9] <- "No locations to randomize"
} else {
rownames(output)[9] <- "No randomization"
}
output[9, 1] <- "-"
}
if (!is.null(object$design$alpha)) {
rownames(output)[10] <- "\nSpecification of Requirements\n-----------------------------"
output[10, 1] <- "-"
rownames(output)[11] <- "Significance level (2-sided):    "
output[11, 1] <- object$design$alpha
rownames(output)[12] <- "Type of Outcome                   "
output[12, 1] <- switch(object$design$outcome_type,
'y' = "continuous",
"n" = "count",
"e" = "event rate",
'p' = "proportion",
'd' = "dichotomous")
rownames(output)[13] <- "Expected outcome in control arm:  "
output[13, 1] <- object$design$yC
link <- switch(object$design$outcome_type,
'y' = "identity",
"n" = "log",
"e" = "log",
'p' = "logit",
'd' = "logit")
rownames(output)[14] <- switch(link,
"identity" = "Expected variance of outcome:     ",
"log" = "Mean rate multiplier:             ",
"cloglog" = "Mean rate multiplier:             ",
"logit" = "Mean denominator:                 ")
output[14, 1] <- switch(link,
"identity" =  object$design$sigma2,
"log" = object$design$denominator,
"cloglog" = object$design$denominator,
"logit" = object$design$N)
if (identical(object$design$outcome_type, 'd')) output[14, 1] <- ""
rownames(output)[15] <- "Required effect size:             "
output[15, 1] <- object$design$effect
rownames(output)[16] <- "Intra-cluster correlation:        "
output[16, 1] <- object$design$ICC
if (!is.null(object$design$buffer_width)) {
rownames(output)[3] <- "Buffer width :               "
if (object$design$buffer_width > 0) {
output[3, 1] <- paste0(object$design$buffer_width,
" km.")
} else {
output[3, 1] <- "No buffer"
}
}
}
output[17, 1] <- "-"
if (is.null(object$design$effect)) {
rownames(output)[17] <- "No power calculations to report"
} else {
rownames(output)[17] <- "\nPower calculations (ignoring contamination)\n------------------                    "
sufficient <- ifelse(clustersAvailableFull >= object$geom_full$clustersRequired,
"Yes", "No")
rownames(output)[18] <- "Design effect:                         "
output[18, 1] <- round(object$geom_full$DE, digits = 1)
rownames(output)[19] <- "Nominal power (%)                      "
output[19, 1] <- round(object$geom_full$power * 100, digits = 1)
rownames(output)[20] <- paste0("Total clusters required (power of ",
object$design$desiredPower * 100, "%):")
output[20, 1] <- object$geom_full$clustersRequired
rownames(output)[21] <- "Sufficient clusters for required power?"
output[21, 1] <- sufficient
if (is.null(object$geom_core$power)) {
output <- subset(output, select = -c(2))
} else {
output[17, 1] <- "Full"
output[17, 2] <- "Core"
clustersAvailableCore <- with(object$geom_core, floor(locations/mean_h))
sufficientCore <- ifelse(clustersAvailableCore >= object$geom_core$clustersRequired,
"Yes", "No")
output[18, 2] <- round(object$geom_core$DE, digits = 1)
output[19, 2] <- round(object$geom_core$power * 100, digits = 1)
output[20, 2] <- object$geom_core$clustersRequired
output[21, 2] <- sufficientCore
}
}
standard.names <- c("x", "y", "cluster", "arm", "buffer", "nearestDiscord",
"geom_full", "geom_core", "design")
rownames(output)[22] <- "\nOther variables in dataset\n--------------------------"
output[22, 1] <- paste(dplyr::setdiff(names(object$trial), standard.names), collapse = "  ")
output
output1 <- output[trimws(output[, 1]) != "", ]
output1
# display and return table
utils::write.table(output, quote = FALSE, col.names = FALSE, sep = "          ")
# display and return table
utils::write.table(output1, quote = FALSE, col.names = FALSE, sep = "          ")
rownames(output)
rownames(output1)
output1
examplePower1 = CRTpower(locations = 3000, ICC = 0.10, effect = 0.4, alpha = 0.05,
outcome_type = 'd', desiredPower = 0.8, yC=0.35, c = 20, sd_h = 5)
summary(examplePower1)
summary(examplePower1)
summary(examplePower1)
summary(examplePower1)
library(CRTspat)
summary(examplePower1)
rownames(output)
rownames(output)
summary(examplePower2)
rownames(output)
summary(examplePower2)
output1 <- output[trimws(output[, 1]) != "", ]
length(output[, 1])
nchar(output[, 1])
type(output[[1]])
typeof(output[[1]])
(output[[1]])
colnames(output)
rownames(output)
output[,1])
output[,1]
output[,1] == ""
output[,1] != ""
trimws(output[, 1]) != ""
library(CRTspat)
summary(examplePower1)
summary(examplePower2)
library(CRTspat)
source("C:/git_repos/CRTspat/vignettes/runVignette.R")
```r
library(CRTspat)
example_locations <- readdata('example_site.csv')
example_locations$base_denom <- 1
exampleCRT <- CRTsp(example_locations)
example <- aggregateCRT(exampleCRT,
auxiliaries = c("RDT_test_result", "base_denom"))
# randomly sample an array of numbers of clusters to allocate
set.seed(5)
c_vec <- round(runif(20, min = 6, max = 60))
CRTscenario <- function(c, CRT, buffer_width) {
ex <- specify_clusters(CRT, c = c, algo = "kmeans") %>%
randomizeCRT() %>%
specify_buffer(buffer_width = buffer_width)
GEEanalysis <- CRTanalysis(ex, method = "GEE", baselineOnly = TRUE, excludeBuffer = TRUE,
baselineNumerator = "RDT_test_result", baselineDenominator = "base_denom")
locations <- GEEanalysis$description$locations
ex_power <- CRTpower(trial = ex, effect = 0.3, yC = GEEanalysis$pt_ests$controlY,
outcome_type = "p", N = GEEanalysis$description$sum.denominators/locations, c = c,
ICC = GEEanalysis$pt_ests$ICC)
value <- c(c_full = c, c_core = ex_power$geom_core$c, clustersRequired = ex_power$geom_full$clustersRequired,
power = ex_power$geom_full$power, mean_h = ex_power$geom_full$mean_h,
locations = locations, ICC = GEEanalysis$pt_ests$ICC)
return(value)
}
results <- t(sapply(c_vec, FUN = CRTscenario, simplify = "array", CRT = example,
buffer_width = 0.5)) %>%
data.frame()
total_locations <- example$geom_full$locations
results$proportion_included <- results$c_core * results$mean_h * 2/total_locations
results$corelocations_required <- results$clustersRequired * results$mean_h
results$totallocations_required <- with(results, total_locations/locations *
corelocations_required)
library(ggplot2)
theme_set(theme_bw(base_size = 14))
ggplot(data = results, aes(x = c_full, y = c_core)) + geom_smooth() + xlab("Clusters allocated (per arm)") +
ylab("Clusters in core (per arm)") + geom_segment(aes(x = 5, xend = 35,
y = 18.5, yend = 18.5), arrow = arrow(length = unit(1, "cm")), lwd = 2,
color = "red")
set.seed(7)
library(dplyr)
example6 <- specify_clusters(example, c = 6, algo = "kmeans") %>%
randomizeCRT() %>%
specify_buffer(buffer_width = 0.5)
plotCRT(example6, map = TRUE, showClusterBoundaries = TRUE, showClusterLabels = TRUE,
labelsize = 2, maskbuffer = 0.2)
example40 <- specify_clusters(example, c = 40, algo = "kmeans") %>%
randomizeCRT() %>%
specify_buffer(buffer_width = 0.5)
plotCRT(example40, map = TRUE, showClusterBoundaries = TRUE, showClusterLabels = TRUE,
labelsize = 2, maskbuffer = 0.2)
ggplot(data = results, aes(x = c_core, y = mean_h)) + geom_smooth() + xlab("Clusters in core (per arm)") +
ylab("Mean cluster size")
ggplot(data = results, aes(x = c_core, y = power)) + geom_smooth() + xlab("Clusters in core (per arm)") +
ylab("Power")
ggplot(data = results, aes(x = c_core, y = power.control)) + geom_smooth() + xlab("Clusters in core (per arm)") +
ylab("Power")
# use the same dataset as for Use Case 1.
library(CRTspat)
example_locations <- readdata('example_site.csv')
example_locations$base_denom <- 1
exampleCRT <- CRTsp(example_locations)
example <- aggregateCRT(exampleCRT,
auxiliaries = c("RDT_test_result", "base_denom"))
# randomly sample an array of numbers of clusters to allocate
set.seed(5)
c_vec <- round(runif(20, min = 6, max = 60))
CRTscenario <- function(c, CRT, buffer_width) {
ex <- specify_clusters(CRT, c = c, algo = "kmeans") %>%
randomizeCRT() %>%
specify_buffer(buffer_width = buffer_width)
GEEanalysis <- CRTanalysis(ex, method = "GEE", baselineOnly = TRUE, excludeBuffer = TRUE,
baselineNumerator = "RDT_test_result", baselineDenominator = "base_denom")
locations <- GEEanalysis$description$locations
ex_power <- CRTpower(trial = ex, effect = 0.3, yC = GEEanalysis$pt_ests$controlY,
outcome_type = "p", N = GEEanalysis$description$sum.denominators/locations, c = c,
ICC = GEEanalysis$pt_ests$ICC)
value <- c(c_full = c, c_core = ex_power$geom_core$c, clustersRequired = ex_power$geom_full$clustersRequired,
power = ex_power$geom_full$power, mean_h = ex_power$geom_full$mean_h,
locations = locations, ICC = GEEanalysis$pt_ests$ICC)
return(value)
}
results <- t(sapply(c_vec, FUN = CRTscenario, simplify = "array", CRT = example,
buffer_width = 0.5)) %>%
data.frame()
junk <- CRTscenario(c = 10, CRT = example, buffer_width = 0.5)
junk
names(junk)
CRTscenario <- function(c, CRT, buffer_width) {
ex <- specify_clusters(CRT, c = c, algo = "kmeans") %>%
randomizeCRT() %>%
specify_buffer(buffer_width = buffer_width)
GEEanalysis <- CRTanalysis(ex, method = "GEE", baselineOnly = TRUE, excludeBuffer = TRUE,
baselineNumerator = "RDT_test_result", baselineDenominator = "base_denom")
locations <- GEEanalysis$description$locations
ex_power <- CRTpower(trial = ex, effect = 0.3, yC = GEEanalysis$pt_ests$controlY,
outcome_type = "p", N = GEEanalysis$description$sum.denominators/locations, c = c,
ICC = GEEanalysis$pt_ests$ICC)
value <- c(c_full = c, c_core = ex_power$geom_core$c, clustersRequired = ex_power$geom_full$clustersRequired,
power = ex_power$geom_full$power, mean_h = ex_power$geom_full$mean_h,
locations = locations, ICC = GEEanalysis$pt_ests$ICC)
names(value) <- c("c_full", "c_core", "clustersRequired", "power", "mean_h", "locations", "ICC")
return(value)
}
results <- t(sapply(c_vec, FUN = CRTscenario, simplify = "array", CRT = example,
buffer_width = 0.5)) %>%
data.frame()
```
```r
# use the same dataset as for Use Case 1.
library(CRTspat)
example_locations <- readdata('example_site.csv')
example_locations$base_denom <- 1
exampleCRT <- CRTsp(example_locations)
example <- aggregateCRT(exampleCRT,
auxiliaries = c("RDT_test_result", "base_denom"))
# randomly sample an array of numbers of clusters to allocate
set.seed(5)
c_vec <- round(runif(20, min = 6, max = 60))
CRTscenario <- function(c, CRT, buffer_width) {
ex <- specify_clusters(CRT, c = c, algo = "kmeans") %>%
randomizeCRT() %>%
specify_buffer(buffer_width = buffer_width)
GEEanalysis <- CRTanalysis(ex, method = "GEE", baselineOnly = TRUE, excludeBuffer = TRUE,
baselineNumerator = "RDT_test_result", baselineDenominator = "base_denom")
locations <- GEEanalysis$description$locations
ex_power <- CRTpower(trial = ex, effect = 0.3, yC = GEEanalysis$pt_ests$controlY,
outcome_type = "p", N = GEEanalysis$description$sum.denominators/locations, c = c,
ICC = GEEanalysis$pt_ests$ICC)
value <- c(c_full = c, c_core = ex_power$geom_core$c, clustersRequired = ex_power$geom_full$clustersRequired,
power = ex_power$geom_full$power, mean_h = ex_power$geom_full$mean_h,
locations = locations, ICC = GEEanalysis$pt_ests$ICC)
names(value) <- c("c_full", "c_core", "clustersRequired", "power", "mean_h", "locations", "ICC")
return(value)
}
results <- t(sapply(c_vec, FUN = CRTscenario, simplify = "array", CRT = example,
buffer_width = 0.5)) %>%
data.frame()
View(results)
total_locations <- example$geom_full$locations
results$proportion_included <- results$c_core * results$mean_h * 2/total_locations
results$corelocations_required <- results$clustersRequired * results$mean_h
results$totallocations_required <- with(results, total_locations/locations *
corelocations_required)
library(ggplot2)
theme_set(theme_bw(base_size = 14))
ggplot(data = results, aes(x = c_full, y = c_core)) + geom_smooth() + xlab("Clusters allocated (per arm)") +
ylab("Clusters in core (per arm)") + geom_segment(aes(x = 5, xend = 35,
y = 18.5, yend = 18.5), arrow = arrow(length = unit(1, "cm")), lwd = 2,
color = "red")
set.seed(7)
library(dplyr)
example6 <- specify_clusters(example, c = 6, algo = "kmeans") %>%
randomizeCRT() %>%
specify_buffer(buffer_width = 0.5)
plotCRT(example6, map = TRUE, showClusterBoundaries = TRUE, showClusterLabels = TRUE,
labelsize = 2, maskbuffer = 0.2)
example40 <- specify_clusters(example, c = 40, algo = "kmeans") %>%
randomizeCRT() %>%
specify_buffer(buffer_width = 0.5)
plotCRT(example40, map = TRUE, showClusterBoundaries =
plotCRT(example40, map = TRUE, showClusterBoundaries = TRUE, showClusterLabels = TRUE,
labelsize = 2, maskbuffer = 0.2)
```r
ggplot(data = results, aes(x = c_core, y = mean_h)) + geom_smooth() + xlab("Clusters in core (per arm)") +
ylab("Mean cluster size")
ggplot(data = results, aes(x = c_core, y = power.control)) + geom_smooth() + xlab("Clusters in core (per arm)") +
ylab("Power")
ggplot(data = results, aes(x = c_core, y = power)) + geom_smooth() + xlab("Clusters in core (per arm)") +
ylab("Power")
knitr::knit("vignettes/Usecase4.Rmd.orig", output = "vignettes/Usecase4.Rmd")
source("C:/git_repos/CRTspat/vignettes/runVignette.R")
rmarkdown.html_vignette.check_title = FALSE
devtools::install(build_vignettes = TRUE)
