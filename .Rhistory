y1 <- arm <- NULL
clusterSum <- data.frame(
trial %>%
group_by(cluster) %>%
dplyr::summarize(
y = sum(y1),
total = sum(y_off),
arm = arm[1]
)
)
clusterSum$lp <- switch(link,
"identity" = clusterSum$y/clusterSum$total,
"log" = log(clusterSum$y/clusterSum$total),
"logit" = logit(clusterSum$y/clusterSum$total))
formula <- stats::as.formula("lp ~ arm")
model.object <- stats::t.test(
formula = formula, data = clusterSum, alternative = "two.sided",
conf.level = 1 - alpha, var.equal = TRUE
)
pt.ests$p.value <- model.object$p.value
analysisC <- stats::t.test(
clusterSum$lp[clusterSum$arm == "control"], conf.level = 1 - alpha)
pt.ests$controlY <- invlink(link, analysisC$estimate[1])
int.ests$controlY <- invlink(link, analysisC$conf.int)
analysisI <- stats::t.test(
clusterSum$lp[clusterSum$arm == "intervention"], conf.level = 1 - alpha)
pt.ests$interventionY <- invlink(link, analysisI$estimate[1])
int.ests$interventionY <- invlink(link, analysisI$conf.int)
# Covariance matrix (note that two arms are independent so the off-diagonal elements are zero)
Sigma <- matrix(
data = c(analysisC$stderr^2, 0, 0, analysisI$stderr^2),
nrow = 2, ncol = 2)
pt.ests$efficacy <- 1 - pt.ests$interventionY/pt.ests$controlY
int.ests$efficacy <- estimateCLEfficacy(
mu = c(analysisC$estimate, analysisI$estimate),
Sigma = Sigma, alpha = alpha, resamples = resamples, method = method,
link = link)
} else if (method == "GEE") {
# GEE analysis of cluster effects
if (link == "log")
{
fterms <- ifelse(
cfunc == "Z", "y1 ~ 1 + offset(log(y_off))", "y1 ~ arm + offset(log(y_off))")
formula <- stats::as.formula(fterms)
fit <- geepack::geeglm(
formula = formula, id = cluster, data = trial, family = poisson(link = "log"),
corstr = "exchangeable", scale.fix = FALSE)
} else if (link == "logit") {
fterms <- ifelse(cfunc == "Z", "cbind(y1,y0) ~ 1", "cbind(y1,y0) ~ arm")
formula <- stats::as.formula(fterms)
fit <- geepack::geeglm(
formula = formula, id = cluster, corstr = "exchangeable",
data = trial, family = binomial(link = "logit"))
} else if (link == "identity") {
fterms <- ifelse(cfunc == "Z", "y1/y_off ~ 1", "y1/y_off ~ arm")
formula <- stats::as.formula(fterms)
fit <- geepack::geeglm(
formula = formula, id = cluster, corstr = "exchangeable",
data = trial, family = gaussian
)
}
summary_fit <- summary(fit)
z <- -qnorm(alpha/2)  #standard deviation score for calculating confidence intervals
lp_yC <- summary_fit$coefficients[1, 1]
se_lp_yC <- summary_fit$coefficients[1, 2]
clusterSize <- nrow(trial)/nlevels(as.factor(trial$cluster))
# remove the temporary objects from the dataframe
fit$model.object$data$y1 <- fit$model.object$data$y0 <- fit$model.object$data$y_off <- NULL
pt.ests$controlY <- invlink(link, lp_yC)
int.ests$controlY <- namedCL(
invlink(link, c(lp_yC - z * se_lp_yC, lp_yC + z * se_lp_yC)),
alpha = alpha
)
pt.ests$model.object <- fit
# Intracluster correlation
pt.ests$ICC <- noLabels(summary_fit$corr[1])  #with corstr = 'exchangeable', alpha is the ICC
se_ICC <- noLabels(summary_fit$corr[2])
int.ests$ICC <- namedCL(
noLabels(c(pt.ests$ICC - z * se_ICC, pt.ests$ICC + z * se_ICC)),
alpha = alpha
)
pt.ests$DesignEffect <- 1 + (clusterSize - 1) * pt.ests$ICC  #Design Effect
int.ests$DesignEffect <- 1 + (clusterSize - 1) * int.ests$ICC
# Estimation of efficacy does not apply if analysis is of baseline only (cfunc='Z')
pt.ests$efficacy <- 0
if (cfunc == "X")
{
lp_yI <- summary_fit$coefficients[1, 1] + summary_fit$coefficients[2,
1]
se_lp_yI <- sqrt(
fit$geese$vbeta[1, 1] + fit$geese$vbeta[2, 2] + 2 * fit$geese$vbeta[1,
2]
)
int.ests$interventionY <- namedCL(
invlink(link, c(lp_yI - z * se_lp_yI, lp_yI + z * se_lp_yI)),
alpha = alpha
)
int.ests$efficacy <- estimateCLEfficacy(
mu = summary_fit$coefficients[, 1], Sigma = fit$geese$vbeta,
alpha = alpha, resamples = resamples, method = method,
link = link
)
pt.ests$interventionY <- invlink(link, lp_yI)
pt.ests$efficacy <- (1 - invlink(link, lp_yI)/invlink(link, lp_yC))
}
} else if (method == "ML")
{
############### ML Methods with contamination functions and logistic link #################
par <- SingleTrialAnalysis(trial = trial, FUN2 = FUN2)
fit <- FittingResults(trial, par = par, FUN1 = FUN1)
pt.ests$controlY <- fit$controlY
pt.ests$interventionY <- fit$interventionY
pt.ests$efficacy <- fit$efficacy
pt.ests$contamination.par <- fit$contamination.par
pt.ests <- pt.ests[names(pt.ests) != "model.object"]
pt.ests$pr.contaminated <- 1  #None of the ML models include local effects
results <- list(
description = description, method = method, pt.ests = pt.ests,
int.ests = int.ests, model.object = model.object
)
if (requireBootstrap)
{
mle <- list(par = par, FUN1 = FUN1, link = "logit")
boot_estimates <- data.frame(V1 = c(), V2 = c(), V3 = c(), V4 = c())
# resampling can crash because of resamples containing data from only one arm to prevent this
# crashing the whole program, bootstrapping is done in batches of 5 resamples using 'try' to avoid
# crashing out
resamples1 <- 5
tries <- 0
while (nrow(boot_estimates) <
resamples)
{
# sample a random value each time through the loop so the seed is change
boot_output <- try(
expr = boot::boot(
data = trial, statistic = SingleTrialAnalysis, R = resamples1,
sim = "parametric", ran.gen = rgen, mle = mle, FUN2 = FUN2
),
silent = TRUE
)
if (!substr(boot_output[1], 1, 5) ==
"Error")
{
new_estimates <- as.data.frame(
t(
matrix(
data = unlist(
apply(
as.data.frame(boot_output$t),
1, FittingResults, trial = trial, FUN1 = FUN1
)
),
ncol = resamples1, nrow = length(fit)
)
)
)
boot_estimates <- rbind(boot_estimates, new_estimates)
}
tries <- tries + 5
cat(
"\r", nrow(boot_estimates),
" bootstrap samples analysed, out of", tries, " tries    \r"
)
}
colnames(boot_estimates) <- names(fit)
bounds <- (apply(
boot_estimates, 2, function(x)
{
quantile(
x, c(alpha/2, 0.5, 1 - alpha/2),
alpha = alpha
)
}
))
results <- add_estimates(results = results, bounds = bounds, CLnames = CLnames)
}
############### INLA Methods #################
} else if (method == "INLA")
{
if (is.null(inla.mesh))
{
inla.mesh <- createMesh(
trial = trial, offset = -0.1, max.edge = 0.25, inla.alpha = 2,
maskbuffer = 0.5, ncells = 50
)
}
y_off <- NULL
# specify functional form of sigmoid in distance from boundary 'L' inverse logit; 'P' inverse probit; 'X'
# or 'Z' do not model contamination
FUN <- switch(
cfunc, L = "invlink(link='logit', x)", P = "stats::pnorm(x)", X = NULL, Z = NULL)
# create model formula
fterms <- switch(link,
"identity" = "y1/y_off ~ 0",
"log" = "y1 ~ 0",
"logit" = "y1 ~ 0"
)
fterms <- c(fterms, switch(
cfunc, Z = "b0",
X = "b0 + b1",
L = "b0 + b1 + pvar",
P = "b0 + b1 + pvar"
))
if (localisedEffects)
fterms <- c(fterms, "b1")
if (clusterEffects)
fterms <- c(fterms, "f(cluster, model = \"iid\")")
if (spatialEffects)
fterms <- c(fterms, "f(s, model = spde)")
# console display of the formula
formula_as_text <- paste(fterms, collapse = " + ")
cat(formula_as_text, "\n")
formula <- stats::as.formula(formula_as_text)
spde <- inla.mesh$spde
effectse <- list(
df = data.frame(
b0 = rep(1, nrow(trial)),
b1 = ifelse(trial$arm == "intervention", 1, 0),
cluster = trial$cluster
),
s = inla.mesh$indexs
)
effectsp <- list(
df = data.frame(
b0 = rep(1, nrow(inla.mesh$prediction)),
b1 = ifelse(inla.mesh$prediction$arm == "intervention", 1, 0),
cluster = inla.mesh$prediction$cluster
),
s = inla.mesh$indexs
)
lc <- NULL
beta2 <- NA
if (cfunc %in% c("L", "P"))
{
cat("Estimating scale parameter for contamination range", "\n")
beta2 <- stats::optimize(
f = estimateContamination, interval = c(-10, 10),
trial = trial, FUN = FUN, inla.mesh = inla.mesh, formula = formula,
tol = 0.1, link = link)$minimum
x <- trial$nearestDiscord * exp(beta2)
trial$pvar <- eval(parse(text = FUN))
effectse$df$pvar <- trial$pvar
x <- inla.mesh$prediction$nearestDiscord * exp(beta2)
inla.mesh$prediction$pvar <- ifelse(
cfunc == "X", rep(NA, nrow(inla.mesh$prediction)),
eval(parse(text = FUN))
)
effectsp$df$pvar <- inla.mesh$prediction$pvar
# set up linear contrasts (not required for cfunc='X' or 'Z')
if (grepl("pvar", formula_as_text, fixed = TRUE))
{
lc <- INLA::inla.make.lincomb(b0 = 1, pvar = 1)
if (grepl("b1", formula_as_text, fixed = TRUE))
{
lc <- INLA::inla.make.lincomb(b0 = 1, pvar = 1, b1 = 1)
}
} else if (grepl("b1", formula_as_text, fixed = TRUE))
{
lc <- INLA::inla.make.lincomb(b0 = 1, b1 = 1)
}
}
# stack for estimation stk.e
stk.e <- INLA::inla.stack(
tag = "est", data = list(y1 = trial$y1, y_off = trial$y_off),
A = list(1, A = inla.mesh$A),
effects = effectse
)
# stack for prediction stk.p
stk.p <- INLA::inla.stack(
tag = "pred", data = list(y1 = NA, y_off = NA),
A = list(1, inla.mesh$Ap),
effects = effectsp
)
# stk.full comprises both stk.e and stk.p
stk.full <- INLA::inla.stack(stk.e, stk.p)
cat("INLA analysis                                                 \n")
if (link == "identity") {
inla.result <- INLA::inla(
formula, family = "gaussian", lincomb = lc,
control.family = list(link = "identity"),
data = INLA::inla.stack.data(stk.full),
control.fixed = list(correlation.matrix = TRUE),
control.predictor = list(compute = TRUE, link = 1,
A = INLA::inla.stack.A(stk.full)),
control.compute = list(dic = TRUE))
} else if (link == "log") {
# For the negative binomial, the mean is linked to the linear predictor by the log transformation
inla.result <- INLA::inla(
formula, family = "nbinomial", E = y_off, lincomb = lc,
control.family = list(prior="gaussian", param = c(0,0.01)),
data = INLA::inla.stack.data(stk.full),
control.fixed = list(correlation.matrix = TRUE),
control.predictor = list(compute = TRUE, link = 1,
A = INLA::inla.stack.A(stk.full)),
control.compute = list(dic = TRUE))
} else if (link == "logit") {
inla.result <- INLA::inla(
formula, family = "binomial", Ntrials = y_off, lincomb = lc,
control.family = list(link = "logit"),
data = INLA::inla.stack.data(stk.full),
control.fixed = list(correlation.matrix = TRUE),
control.predictor = list(compute = TRUE, link = 1,
A = INLA::inla.stack.A(stk.full)),
control.compute = list(dic = TRUE))
}
# Augment the inla results list with application specific quantities
index <- INLA::inla.stack.index(stack = stk.full, tag = "pred")$data
inla.mesh$prediction$proportion <- invlink(link, inla.result$summary.linear.predictor[index, "0.5quant"])
# Compute sample-based confidence limits for intervened outcome and efficacy if intervention effects are
# estimated
if (grepl("pvar", formula_as_text, fixed = TRUE) |
grepl("b1", formula_as_text, fixed = TRUE))
{
# Specify the means of the variables
mu <- inla.result$summary.lincomb.derived$mean
names(mu) <- rownames(inla.result$summary.lincomb.derived)
# Specify the covariance matrix of the variables
cov <- inla.result$misc$lincomb.derived.covariance.matrix
sample <- as.data.frame(MASS::mvrnorm(n = 10000, mu = mu, Sigma = cov))
sample$controlY <- invlink(link, sample$b0)
# pr.contaminated is the proportion of effect subject to contamination
if ("b1" %in% names(mu) &
"pvar" %in% names(mu))
{
sample$interventionY <- invlink(link, sample$lc)
sample$pr.contaminated <- with(
sample, 1 - (controlY - invlink(link, b0 + b1))/(controlY -
interventionY)
)
} else if ("b1" %in% names(mu))
{
sample$interventionY <- invlink(link, sample$b0 + sample$b1)
sample$pr.contaminated <- 0
} else if ("pvar" %in% names(mu))
{
sample$interventionY <- invlink(link, sample$b0 + sample$pvar)
sample$pr.contaminated <- 1
}
sample$efficacy <- 1 - sample$interventionY/sample$controlY
bounds <- (apply(
sample, 2, function(x)
{
quantile(
x, c(alpha/2, 0.5, 1 - alpha/2),
alpha = alpha
)
}
))
} else
{
controlY <- unlist(
invlink(
link, inla.result$summary.fixed["b0", c("0.025quant", "0.5quant", "0.975quant")]
)
)
bounds <- data.frame(
controlY = controlY, interventionY = controlY, efficacy = rep(0, 3),
pr.contaminated = rep(0, 3)
)
}
results <- list(
model.object = inla.result, inla.mesh = inla.mesh, pt.ests = list(),
int.ests = list(), method = method
)
results <- add_estimates(results = results, bounds = bounds, CLnames = CLnames)
results$int.ests$pr.contaminated <- stats::setNames(
bounds[c(1, 3),
"pr.contaminated"], CLnames
)
results$pt.ests$pr.contaminated <- bounds[2, "pr.contaminated"]
results$passed.face.validity.check <- TRUE
if (results$pt.ests$pr.contaminated < 0 | results$pt.ests$pr.contaminated >
1)
{
cat(
"** Warning: different signs for main effect and contamination: face validity check fails **\n"
)
results$passed.face.validity.check <- FALSE
results$pt.ests$pr.contaminated <- NA
results$int.ests$pr.contaminated <- c(NA, NA)
}
results$pt.ests$contamination.par <- beta2
results$description <- description
}
if (method %in% c("EMP", "ML", "T", "GEE"))
{
# tidy up and consolidate the list of results
model.object <- pt.ests$model.object
pt.ests <- pt.ests[names(pt.ests) !=
"GAsolution3"]
pt.ests <- pt.ests[names(pt.ests) !=
"model.object"]
results <- list(
description = description, method = method, pt.ests = pt.ests,
int.ests = int.ests, model.object = model.object
)
}
if (cfunc != "Z")
{
results$contamination <- getContaminationCurve(trial = trial, pt.ests = results$pt.ests, FUN1 = FUN1, link = link)
results$pt.ests$contaminationRange <- results$contamination$contaminationRange
results$contamination$contaminationRange <- NULL
} else
{
results$pt.ests$contaminationRange <- NA
}
## Output to screen
cat(
"Analysis model: ", method, "Link function: ", link, "Contamination option: ",
cfunc, "\n"
)
CLtext <- paste0(" (", 100 * (1 - alpha), "% CL: ")
cat(
"Estimated Proportions-      Control: ", results$pt.ests$controlY,
CLtext, unlist(results$int.ests$controlY),
")\n"
)
if (results$pt.ests$efficacy != 0)
{
if (!is.null(results$pt.ests$interventionY))
{
cat(
"                       Intervention: ", results$pt.ests$interventionY,
CLtext, unlist(results$int.ests$interventionY),
")\n"
)
cat(
"Efficacy: ", results$pt.ests$efficacy, CLtext, unlist(results$int.ests$efficacy),
")\n"
)
}
if (!is.na(results$pt.ests$pr.contaminated))
{
cat(
"Proportion of effect subject to contamination: ", results$pt.ests$pr.contaminated,
CLtext, unlist(results$int.ests$pr.contaminated),
")\n"
)
}
}
if (!is.null(pt.ests$ICC))
{
cat(
"Estimated intracluster correlation (ICC): ", results$pt.ests$ICC,
CLtext, unlist(results$int.ests$ICC),
")\n"
)
}
if (!is.na(results$pt.ests$contaminationRange))
{
cat(
"Contamination Range: ", results$pt.ests$contaminationRange,
"\n"
)
}
if (!is.null(results$model.object$dic$dic) &
cfunc %in% c("L", "P"))
{
# The contamination parameter is not estimated by INLA but should be considered in the DIC
results$model.object$dic$dic <- results$model.object$dic$dic + 2
cat(
"DIC: ", results$model.object$dic$dic, " including penalty for the contamination parameter\n"
)
} else if (!is.null(results$model.object$dic$dic))
{
cat("DIC: ", results$model.object$dic$dic, "\n")
}
return(results)
}
analysis_iden <- Analyse_CRT(trial=test_Simulate_CRT,method = 'INLA',link='log',clusterEffects=TRUE, cfunc='P',inla.mesh = inlaMesh100)
mu
analysis_iden <- Analyse_CRT(trial=test_Simulate_CRT,method = 'INLA',link='log',clusterEffects=TRUE, cfunc='P',inla.mesh = inlaMesh100)
limits
pt.ests
install.packages("remotes")
remotes::install_github("ThomasASmith/CRTspillover")
library(CRTspillover)
load("C:/git_repos/Furvela_Entomology/timeseriesAnalyses.RData")
requireResimulation <- FALSE
################ MAIN PROGRAM STARTS HERE BY READING IN DATA #####################
# if necessary set working directory
setwd("../Furvela_Entomology")
############## DATA DESCRIPTION #############
# Creation of data summaries and workfile (essential for subsequent analysis)
source("R-code/summarize_data.r")
requireResimulation <- FALSE
################ MAIN PROGRAM STARTS HERE BY READING IN DATA #####################
# if necessary set working directory
setwd("../Furvela_Entomology")
############## DATA DESCRIPTION #############
# Creation of data summaries and workfile (essential for subsequent analysis)
source("R-code/summarize_data.r")
requireResimulation <- FALSE
################ MAIN PROGRAM STARTS HERE BY READING IN DATA #####################
# if necessary set working directory
setwd("../Furvela_Entomology")
############## DATA DESCRIPTION #############
# Creation of data summaries and workfile (essential for subsequent analysis)
source("R-code/summarize_data.r")
############## DATA ANALYSIS #############
# To load pre-existing analysis results
load("timeseriesAnalyses.RData")
############ PLOTTING OF RESULTS #############
requirePlotoutput <- TRUE
source("R-code/plotting.r")
############ PLOTTING OF RESULTS #############
requirePlotoutput <- TRUE
source("R-code/plotting.r")
? pdf
18.5/2.5
source("R-code/plotting.r")
dev.off()
