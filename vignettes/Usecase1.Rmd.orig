---
title: "Use Case 1: Algorithmic definition of clusters and of buffer zones"
output:
  rmarkdown::html_vignette:
  toc: true
vignette: >
  %\VignetteIndexEntry{Use Case 1: Algorithmic definition of clusters and of buffer zones}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---
<!--To build the vignette
# since the vignette takes a long time to run, it is not run with every build
# as suggested here https://ropensci.org/blog/2019/12/08/precompute-vignettes/
# to Knit this vignette without this time consuming step being part of the default build
knitr::knit("vignettes/Usecase1.Rmd.orig", output = "vignettes/Usecase1.Rmd")
rmarkdown.html_vignette.check_title = FALSE
devtools::install(build_vignettes = TRUE)
-->

### Use Case 1: Algorithmic definition of clusters and of buffer zones for a CRT

Input to the `CRTspat` package is in the form of a data frame with one record for each location. Most of the functions of the package return a list of class `CRTspat`, which consists of the input data frame augmented with additional vectors (e.g. coding clusters, arms, or buffer zones), and lists containing descriptors of the dataset. Objects of class `CRTspat` can also be used as input to most of the functions.

After each step, `summary` can be used to provide a description of the output `CRTspat` object and `plot` can be used to output a descriptive plot, or a map of the locations, clusters, arms, buffer zones or other geographically structured analysis results.

The starting point for the analyses is the co-ordinates for the spatial units that are to be randomized.
 These can be provided as lat-long coordinates, as Cartesian point co-ordinates with centroid (0,0). Simulated co-ordinate sets can also be generated *de novo* (function `simulateSite`). The `convert.latlong.xy` function is available to convert co-ordinates provided as decimal degrees into Cartesian co-ordinates with units of km. (If the input co-ordinates are provided using a different projection then they must be converted externally to the package).

+ In general the package functions do not expect to find repeated values for outcomes for the same location. The `aggregateCRT` function is used to aggregate data with the same co-ordinates so that this condition is satisfied. In particular, if the input database contains outcome data (e.g. if it contains baseline survey results), these should be provided in the form of a numerator `base_num` and denominator ´base_denom´ for each record. These values will be summed by `aggregateCRT` over all records with the same co-ordinates. An object of class `CRT` is output.

+ The `specify.clusters` function carries out algorithmic assignment of clusters and outputs a `trial` data frame augmented with the cluster assignments. One of three different algorithms must be selected:
  + `algo="NN"` implements a [nearest neighbour algorithm](https://en.wikipedia.org/wiki/Nearest-neighbor_chain_algorithm) which takes a collection of points as input, and creates clusters of points by repeatedly merging in points to form larger clusters. This is the default option.
  + `algo="TSP"` implements the "repetitive_nn" option of the `TSP` package for solving the travelling salesman problem. This finds an efficient path through the study locations. Clusters are formed by grouping the required number of locations sequentially along the path. Note that this is not guaranteed to give rise to congruent clusters.
  + `algo="kmeans"` implements a [k-means algorithm](https://en.wikipedia.org/wiki/K-means_clustering) that aims to partition the locations into the required number of clusters in which each observation belongs to the cluster with the nearest cluster centroid. k-means clustering minimizes within-cluster variances (squared Euclidean distances) but does not necessarily give equal-sized clusters.
Irrespective of the algorithm, the target number of points allocated to each cluster is specified by the parameter `h`.
+ The `Randomize_CRT` function carries out a simple randomization of clusters to arms, and outputs a `trial` data frame augmented with the assignments. (If baseline data are available matched pair randomization is available as an option)

The units to be randomized will usually be households, but the algorithms can be used to generate clusters with equal geographical areas by randomizing pixels.

The example uses locations from Rusinga Island, Kenya. (The example dataset also contains multiple records
of test positivity from a baseline survey)

#### Example
```{r example1.r, fig.path=('vignettes/figures/'),echo=TRUE}
example_locations <- readdata('example_baseline.csv')
# assign the denominator to the baseline data
example_locations$base_denom <- 1
# convert to Euclidean coordinates
example_xy <- latlong_as_xy(example_locations)
summary(example_xy)
# Aggregate data for multiple observations for the same location Only the (x,y) co-ordinates and numerical
# auxiliary variables
example_aggregated <- aggregate(example_xy, auxiliaries = c("RDT_test_result", "base_denom"))
summary(example_aggregated)
# Plot map of locations
plot(example_aggregated, map = TRUE, showLocations = TRUE, maskbuffer = 0.5)
example_clustered <- specify.clusters(trial = example_aggregated, h = 50, algorithm = 'NN')
summary(example_clustered)
plot(example_clustered, map = TRUE, showClusterLabels = TRUE, maskbuffer = 0.5)
example_randomized <- randomizeCRT(example_clustered, matchedPair = TRUE)
summary(example_randomized)
plot(example_randomized, map = TRUE, maskbuffer=0.5,legend.position=c(0.2,0.8))
```
