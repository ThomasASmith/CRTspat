#' Map of CRT trial area
#'
#' \code{plotCRTmap} returns a graphics object created using ggplot2.
#' Cartesian (x,y) coordinates are used. Units are expected to be km.
#'
#' @param trial an object of class \code{CRT} or a data frame containing locations in (x,y) coordinates, cluster
#'   assignments (factor \code{cluster}), and arm assignments (factor \code{arm}) and outcome data (see details).

#' @param showLocations logical: determining whether household locations are shown
#' @param showClusterBoundaries logical: determining whether clusters are shown
#' @param showClusterLabels logical: determining whether clusters are numbered
#' @param colourClusters logical: determining whether clusters are coloured
#' @param showArms logical: determining whether the areas assigned to each trial arm are shown
#' @param analysis list: analysis object generated by analyseCRT
#' @param showDistance logical: determining whether smoothed raster of the distance from nearest discordant location is shown
#' @param showPrediction logical: determining whether a smoothed raster of the fitted Prediction is shown
#' @param showContamination logical: determining whether the estimated contamination range should be shown
#' @param cpalette colour palette (to use different colours for clusters must be at least as long as the number of clusters, defaults to rainbow())
#' @param maskbuffer radius of buffer drawn around inhabited areas
#' @param labelsize size of labels giving cluster numbers
#' @param legend.position for plot of trial arms (using ggplot2::themes syntax)
#' @return graphics object produced by the ggplot2 package
#' @importFrom magrittr %>%
#' @importFrom dplyr distinct group_by summarize
#' @importFrom ggplot2 geom_polygon
#' @export
#'
#' @examples
#' #Plot locations only
#' plotCRTmap(trial = readdata('test_CRT2.csv'), showArms=FALSE,showClusterBoundaries=FALSE,
#'            colourClusters=FALSE, maskbuffer=0.2)
#'
#' #Plot clusters in colour
#' plotCRTmap(trial=readdata('test_CRT2.csv'), showArms=FALSE, colourClusters=TRUE,
#'           labelsize=2, maskbuffer=0.2)
#'
#' #Plot arms
#' plotCRTmap(trial=readdata('test_CRT2.csv'), maskbuffer=0.2, legend.position=c(0.2,0.8))
#'
#' #Plot distance to nearest discordant location
#'

plotCRTmap <- function(trial = trial, showLocations = TRUE, showClusterBoundaries = TRUE, showClusterLabels = TRUE,
                        colourClusters = TRUE, showArms = TRUE, analysis = NULL, showDistance = FALSE, showPrediction = FALSE, showContamination = FALSE,
                        cpalette = NULL, maskbuffer = 0.2, labelsize = 4, legend.position = NULL){

  slot <- cluster <- x <- y <- long <- lat <- prediction <- nearestDiscord <- NULL

  # The voronoi functions requires input as a data.frame not a tibble
  class(trial) <- "data.frame"

  # The plotting routines require unique locations
  trial <- aggregateCRT(trial = trial)

  # The plotting routines use (x,y) coordinates
  if (is.null(trial$x)) {
    trial <- convert.latlong.xy(trial)
  }

  # remove any buffer zones
  class(trial) <- "data.frame"
  if (!is.null(trial$buffer)) {
    trial <- trial[!trial$buffer, ]
  }

  # Adjust the required plots to exclude those for which there is no data or combinations that are too
  # cluttered or overprinted

  if (is.null(analysis)) {
    showdistance <- FALSE
    showPrediction <- FALSE
  } else if (showPrediction) {
    showdistance <- FALSE
    colourClusters <- FALSE
    showArms <- FALSE
  } else if (showDistance) {
    colourClusters <- FALSE
    showArms <- FALSE
  }
  if (is.null(trial$cluster)) {
    trial$cluster <- 1
    showClusterBoundaries <- FALSE
    showClusterLabels <- FALSE
  }
  if (is.null(trial$arm)) {
    trial$arm <- 0
    showArms <- FALSE
  }
  if (!showClusterBoundaries) {
    showClusterLabels <- FALSE
  }
  if (showArms) {
    # palette defaults to a standard colour-blind compatible
    if (is.null(cpalette)) {
      cpalette <- c("#b2df8a", "#1f78b4")
    }
  }
  if (showClusterLabels) {
    showLocations <- FALSE
  }

  # the coordinates should all be Cartesian at this point but long and lat appear later (??)
  trial$long <- trial$x
  trial$lat <- trial$y

  trial1 <- trial  #a copy is required because trial is converted to a SpatialPointsDataFrame
  sp::coordinates(trial) <- c("x", "y")
  totalClusters <- length(unique(trial$cluster))

  # can give negative values
  sp_dat <- data.frame(trial$cluster, trial$arm)

  vor_desc <- deldir::tile.list(deldir::deldir(trial$x, trial$y))
  # tile.list extracts the polygon data from the deldir computation
  lapply(1:(length(vor_desc)), function(i) {

    # tile.list gets us the points for the polygons but we still have to close them, hence the need for the
    # rbind
    tmp <- cbind(vor_desc[[i]]$x, vor_desc[[i]]$y)
    tmp <- rbind(tmp, tmp[1, ])  #add first point to the end of the list
    # now we can make the Polygon(s)
    sp::Polygons(list(sp::Polygon(tmp)), ID = i)

  }) -> vor_polygons

  # match the data & voronoi polys
  rownames(sp_dat) <- sapply(slot(sp::SpatialPolygons(vor_polygons), "polygons"), slot, "ID")

  vor <- sp::SpatialPolygonsDataFrame(sp::SpatialPolygons(vor_polygons), data = sp_dat)
  # TODO try using sf::st_union() to avoid the warning about GEOS support
  vor <- sf::st_as_sf(vor)
  #vor_df1 <- rgeos::gUnaryUnion(vor, id = vor@data$trial.cluster)
  vor_df1 <- sf::st_union(vor, by_feature = TRUE, is_coverage = TRUE)

  # Positions of centroids of clusters for locating the labels centroids <-coordinates(vor_df1)
  cc <- data.frame(trial1 %>%
                     group_by(cluster) %>%
                     dplyr::summarize(x = mean(x), y = mean(y), .groups = "drop"))
  # cc <- data.frame(x = centroids[,1],y = centroids[,2], cluster = c(1:length(centroids[,1])))
  d <- ggplot2::fortify(vor_df1)


  # mask to shade out cluster boundaries in uninhabited areas
  buf1 <- rgeos::gBuffer(trial, width = maskbuffer, byid = TRUE)
  buf2 <- rgeos::gUnaryUnion(buf1)
  buf3 <- ggplot2::fortify(buf2)
  vertices <- data.frame(long = c(min(d$long), min(d$long), max(d$long), max(d$long)),
                         lat = c(min(d$lat), max(d$lat), max(d$lat), min(d$lat)), id = rep(1, 4))
  common_cols <- intersect(colnames(buf3), colnames(vertices))
  gp2 <- vertices
  # make sure that after each hole your x,y coordinates return to the same place.
  # This stops the line buzzing all around and crossing other polygons...
  for (i in unique(buf3$piece)) {
    start <- min(which(buf3$piece == i))
    end <- max(which(buf3$piece == i))
    gp2 <- rbind(gp2, buf3[start:end, common_cols])
    gp2 <- rbind(gp2, vertices[4, common_cols])
  }

  # create a layer for the arms:each cluster separately to avoid overlays with an unwanted polygon due to
  # non-congruent arms
  d2 <- mgcv::uniquecombs(sp_dat)
  d$arm <- d2$trial.arm[as.numeric(d$id)]

  if (is.null(cpalette)) cpalette <- sample(rainbow(totalClusters))
  if (totalClusters == 1) cpalette <- c("white")

  g <- ggplot2::ggplot() + ggplot2::theme_bw()

  # ggplot2 plot each cluster separately to avoid overlays with an unwanted polygon

  for (i in 1:totalClusters) {
    # include an invisible graphic of cluster boundaries to constrain the shape/size
    g <- g + get_Polygon(polygon_type = "limits", i = i,
                         totalClusters = totalClusters, d = d, x = long, y = lat,
                         cpalette = cpalette)
    if (showClusterBoundaries) {
      g <- g + get_Polygon(polygon_type = "clusterboundaries", i = i,
                           totalClusters = totalClusters, d = d, x = long,
                           y = lat, cpalette = cpalette)
    }
    if (colourClusters) {
      g <- g + get_Polygon(polygon_type = "colouredclusters", i = i,
                           totalClusters = totalClusters, d = d, x = long,
                           y = lat, cpalette = cpalette)
    }
    if (showArms) {
      g <- g + get_Polygon(polygon_type = "arms", i = i,
                           totalClusters = totalClusters, d = d, x = long, y = lat,
                           cpalette = cpalette)
    }
  }
  if (showArms) {
    g <- g + ggplot2::scale_fill_manual(name = "Arms", values = cpalette, labels = c("Control", "Intervention"))
    g <- g + ggplot2::coord_equal()
    g <- g + ggplot2::theme(legend.position = legend.position)
  }

  ############ raster images derived from inla analysis #############
  if (showPrediction) {
    g <- g + ggplot2::geom_tile(data = analysis$inla.mesh$prediction,
                                aes(x = x, y = y, fill = prediction), alpha = 0.5)
    g <- g + ggplot2::scale_fill_gradient(name = "Prediction", low = "blue", high = "orange")
  }
  if (showDistance) {
    g <- g + ggplot2::geom_tile(data = analysis$inla.mesh$prediction,
                                aes(x = x, y = y, fill = nearestDiscord),
                                alpha = 0.5)
    g <- g + ggplot2::scale_fill_gradient(name = "Distance", low = "blue", high = "orange")

  }
  if (showContamination) {
    # augment the prediction grid with a classifier of whether the point is within the contamination interval
    range <- analysis$contamination$contamination.limits
    analysis$inla.mesh$prediction$contaminated <- ifelse(dplyr::between(analysis$inla.mesh$prediction$nearestDiscord,
                                                                       range[1], range[2]), TRUE, FALSE)
    g <- g + ggplot2::geom_raster(data = analysis$inla.mesh$prediction[analysis$inla.mesh$prediction$contaminated,
    ], aes(x = x, y = y), fill = "black", alpha = 0.2)

  }
  ####################################################################

  if (showLocations) {
    g <- g + ggplot2::geom_point(data = trial1, aes(x = x, y = y), size = 0.5)
  }
  # mask for remote areas
  g <- g + ggplot2::geom_polygon(data = gp2, aes(x = long, y = lat), colour = NA, fill = "grey")
  if (showClusterLabels) {
    g <- g + ggplot2::geom_text(data = cc, aes(x = x, y = y, label = cluster), hjust = 0.5, vjust = 0.5, size = labelsize)
  }
  g <- g + ggplot2::theme(axis.title = ggplot2::element_blank())

  return(g)
}

#### Create different layers for plotting
get_Polygon <- function(polygon_type, i, totalClusters = totalClusters, d = d, x = long, y = lat, cpalette = cpalette) {

  lat <- long <- arm <- NULL

  if (polygon_type == "limits") {
    # invisible cluster boundaries to constrain shape
    polygon <- ggplot2::geom_polygon(data = d[as.numeric(d$id) == i, ],
                                     aes(x = long, y = lat), colour = "white",
                                     fill = "white")
  } else if (polygon_type == "clusterboundaries") {
    polygon <- ggplot2::geom_polygon(data = d[as.numeric(d$id) == i, ],
                                     aes(x = long, y = lat), colour = "gray",
                                     fill = "white", size = 0.5)
  } else if (polygon_type == "colouredclusters") {
    if (is.null(cpalette))
      cpalette <- sample(rainbow(totalClusters))
    polygon <- ggplot2::geom_polygon(data = d[as.numeric(d$id) == i, ],
                                     aes(x = long, y = lat), colour = "gray",
                                     fill = cpalette[i])
  } else if (polygon_type == "arms") {
    polygon <- ggplot2::geom_polygon(data = d[as.numeric(d$id) == i, ],
                                     aes(x = long, y = lat, fill = arm), colour = "black")
  }
  return(polygon)
}


#' \code{plotContamination} returns a plot of an estimated contamination function
#' @param analysis list object of class CRT produced by \code{analyseCRT()}
#' @return graphics object produced by the ggplot2 package
#' @importFrom ggplot2 aes
#' @details The fitted contamination function is plotted as a continous blue line against the distance from the nearest discordant
#' location.Using the same axes, data summaries are plotted for ten categories of distance from the boundary. Both the
#' average of the outcome and confidence intervals are plotted. \cr
#' For analyses with logit link function the outcome is plotted as a proportion. \cr
#' For analyses with log link function the outcome is plotted on a scale of the Williams' mean
#' (mean of exp(log(x + 1))) - 1) \cr
#' @export
#'
#' @examples
#' plotContamination(analysis = readdata('test_Analyse_CRT.txt'))

plotContamination <- function(analysis) {
  d <- average <- upper <- lower <- contaminationFunction <- NULL
  interval <- analysis$contamination$contamination.limits
  g <- ggplot2::ggplot(data = analysis$contamination$data,aes(x = d, y = average))
  g <- g + ggplot2::theme_bw()
  g <- g + ggplot2::geom_point(size = 2)
  g <- g + ggplot2::geom_errorbar(mapping = aes(x = d, ymin = upper, ymax = lower),linewidth = 0.5, width = 0.1)
  g <- g + ggplot2::geom_line(data = analysis$contamination$FittedCurve,
                              aes(x = d, y = contaminationFunction), linewidth = 2, colour = "#0072A7")
  g <- g + ggplot2::geom_vline(xintercept = interval, linewidth = 1)
  g <- g + ggplot2::geom_vline(xintercept = 0, linewidth = 1, linetype = "dashed")
  g <- g + ggplot2::geom_rect(aes(xmin = interval[1], xmax = interval[2], ymin = -Inf, ymax = Inf), fill = alpha("#2C77BF", 0.02))
  g <- g + ggplot2::xlab("Distance from boundary (km)")
  g <- g + ggplot2::ylab("Outcome")
  return(g)
}


#' \code{plotDataByDistance} returns a stacked bar chart of the grouped data
#' the outcome grouped by distance from the arm boundary
#' @param trial a dataframe containing locations (x,y), cluster assignments, and arm assignments
#' @param num name of numerator variable
#' @param denom name of denominator variable
#' @param cpalette colour palette (to use different colours for clusters must be at least as long as the number of clusters, defaults to rainbow())
#' @return graphics object produced by the ggplot2 package
#' @importFrom ggplot2 aes alpha
#' @export
#'
#' @examples
#' plotDataByDistance(trial=readdata('test_Simulate_CRT.csv'))

plotDataByDistance <- function(trial = trial, num = num, denom = denom,
                                cpalette = c("#D55E00", "#0072A7")) {
  outcome <- positives <- negatives <- frequency <- dcat <- NULL
  analysis <- analyseCRT(trial = trial, method = "EMP")
  analysis$contamination$data$negatives <- with(analysis$contamination$data, total - positives)
  analysis$contamination$data$dcat <- with(analysis$contamination,
                                           min(FittedCurve$d) + (data$cats - 0.5) * (max(FittedCurve$d) -
                                                                                       min(FittedCurve$d))/10)
  data <- tidyr::gather(analysis$contamination$data[, c("dcat", "negatives", "positives")], outcome, frequency, positives:negatives,
                        factor_key = TRUE)
  plot <- ggplot2::ggplot(data = data,
                          aes(x = dcat, y = frequency, fill = outcome)) +
    ggplot2::theme_bw() + ggplot2::geom_bar(stat = "identity") +
    ggplot2::scale_fill_manual(values = cpalette, labels = c("Positive", "Negative")) +
    ggplot2::geom_vline(xintercept = 0,                                                                                                                 linewidth = 1, linetype = "dashed") + ggplot2::xlab("Distance from boundary (km)") + ggplot2::ylab("Frequency") +
    ggplot2::theme(legend.position = "bottom")
  return(plot)
}
