% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/simulateCRT.R
\name{simulateCRT}
\alias{simulateCRT}
\title{Simulation of cluster randomized trial with contamination}
\usage{
simulateCRT(
  trial = NULL,
  efficacy = 0,
  outcome0 = NULL,
  generateBaseline = TRUE,
  matchedPair = TRUE,
  scale = "proportion",
  baselineNumerator = "base_num",
  baselineDenominator = "base_denom",
  denominator = NULL,
  ICC_inp = NULL,
  sd = NULL,
  theta_inp = NULL,
  tol = 1e-04,
  vr = 0.5
)
}
\arguments{
\item{trial}{an object of class \code{CRT} or a data frame containing locations in (x,y) coordinates, cluster
assignments (factor \code{cluster}), and arm assignments (factor \code{arm}). Each location may also be
assigned a \code{propensity} (see details).}

\item{efficacy}{numeric. The simulated efficacy (defaults to 0)}

\item{outcome0}{numeric. The anticipated value of the outcome in the absence of intervention}

\item{generateBaseline}{logical. If \code{TRUE} then baseline data should be simulated}

\item{matchedPair}{logical. If \code{TRUE} then pair-matching on the baseline data should be used in randomization}

\item{scale}{measurement scale of the outcome. Options are: 'proportion' (the default); 'count'; 'continuous'.}

\item{baselineNumerator}{optional name of numerator variable for baseline data}

\item{baselineDenominator}{optional name of denominator variable for baseline data}

\item{denominator}{optional name of denominator variable for the outcome}

\item{ICC_inp}{numeric. Target intra cluster correlation, provided as input when baseline data are to be simulated}

\item{sd}{numeric. standard deviation of the normal kernel measuring spatial smoothing leading to contamination}

\item{theta_inp}{numeric. input contamination range}

\item{tol}{numeric. tolerance of output ICC}

\item{vr}{numeric. ratio of location variance to cluster variance (for continuous outcomes)}
}
\value{
A list of class \code{CRT} containing the following components:
\tabular{llll}{
\code{input.parameters}\tab list \tab values of input parameters to the function \cr
\code{CRT.design.full}\tab list \tab summary statistics describing the site,
cluster assignments, and randomization \cr
\code{x} \tab numeric vector \tab x-coordinates of locations \cr
\code{y} \tab numeric vector \tab y-coordinates of locations \cr
\code{cluster} \tab factor \tab assignments to cluster of each location  \cr
\code{arm} \tab factor \tab assignments to \code{control} or \code{intervention} for each location \cr
\code{nearestDiscord} \tab numeric vector \tab Euclidean distance to nearest discordant location (km) \cr
\code{propensity} \tab numeric vector \tab propensity of location \cr
\code{base_denom} \tab numeric vector \tab denominator for baseline \cr
\code{base_num} \tab numeric vector \tab numerator for baseline \cr
\code{denom} \tab numeric vector \tab denominator for the outcome \cr
\code{num} \tab numeric vector \tab numerator for the outcome \cr
\code{...} \tab\tab other objects included in the input \code{CRT} object
or \code{data.frame}\cr
}
}
\description{
\code{simulateCRT} generates simulated data for a cluster randomized trial (CRT) with geographic contamination between arms.
}
\details{
Synthetic data are generated by sampling around the values of
variable \code{propensity}, which is a numerical vector
(taking positive values) of length equal to the number of locations.
There are three ways in which \code{propensity} can arise:
\enumerate{
\item \code{propensity} can be provided as part of the input \code{trial} object.
\item Baseline numerators and denominators (values of \code{baselineNumerator}
and \code{baselineDenominator} may be provided.
\code{propensity} is then generated as the numerator:denominator ratio
for each location in the input object
\item Otherwise \code{propensity} is generated using a 2D Normal
kernel density adjusting the bandwidth iteratively to achieve
an intra-cluster correlation coefficient (ICC) that approximates
the value of \code{ICC_inp}.
}
\code{num[i]}, the synthetic outcome for location \code{i}
is simulated with expectation: \cr
\deqn{\code{E(num[i]) = outcome0[i] * propensity[i] * denom[i] * (1 - efficacy*I[i])/mean(outcome0[] * propensity[])}} \cr \cr
The sampling distribution of \code{num[i]} depends on the value of \code{scale} as follows: \cr
\tabular{llll}{
\code{scale}=’continuous’ \tab Values of \code{num} are sampled from a
Normal distributions with means \code{E(num[i])}
and variance determined by \code{vr} and the fitting to \code{ICC_inp}.\cr
\code{scale}=’count’ \tab Simulated events are allocated to locations via multivariate hypergeometric distributions
parameterised with \code{E(num[i])}.\cr
\code{scale}=’proportion’\tab Simulated events are allocated to locations via multinomial distributions
parameterised with \code{E(num[i])}.\cr
}
\code{denominator} may specify a vector of numeric (non-zero) values
in the input \code{CRT} or \code{data.frame} which is returned
as variable \code{denom}. It acts as a scale-factor for continuous outcomes, rate-multiplier
for counts, or denominator for proportions. For discrete data all values of \code{denom}
must be > 0.5 and are rounded to the nearest integer in calculations of \code{num}.\cr\cr
By default, \code{denom} is generated as a vector of ones, leading to simulation of
dichotomous outcomes if \code{scale}=’proportion’.\cr\cr

If baseline numerators and denominators are provided then the output vectors
\code{base_denom} and  \code{base_num} are set to the input values. If baseline numerators and denominators
are not provided then the synthetic baseline data are generated by sampling around \code{propensity} in the same
way as the outcome data, but with the efficacy set to zero.

Either \code{sd} or \code{theta_inp} must be provided. If both are provided then
the value of \code{sd} is overwritten
by the standard deviation implicit in the value of \code{theta_inp}.
Contamination is simulated as arising from a diffusion-like process.

For further details see \href{https://edoc.unibas.ch/85228/}{Multerer (2021)}
}
\examples{
example_simulated_CRT =  simulateCRT(trial=readdata('test_Arms.csv'),
                                     efficacy=0.25,
                                     ICC_inp=0.05,
                                     outcome0=0.5,
                                     matchedPair = FALSE,
                                     scale='proportion',
                                     sd=0.6,
                                     tol=0.05)
}
